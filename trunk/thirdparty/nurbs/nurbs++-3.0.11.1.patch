Only in /home/makerpm/nurbs++-3.0.11/config: Makefile
Only in /home/makerpm/nurbs++-3.0.11/: config.log
Only in /home/makerpm/nurbs++-3.0.11/: config.status
Only in /home/makerpm/nurbs++-3.0.11/: Doxyfile
Only in /home/makerpm/nurbs++-3.0.11/examples/image: .deps
Only in /home/makerpm/nurbs++-3.0.11/examples/image: Makefile
Only in /home/makerpm/nurbs++-3.0.11/examples: Makefile
Only in /home/makerpm/nurbs++-3.0.11/examples/matrix: .deps
Only in /home/makerpm/nurbs++-3.0.11/examples/matrix: Makefile
Only in /home/makerpm/nurbs++-3.0.11/examples/numerical: .deps
Only in /home/makerpm/nurbs++-3.0.11/examples/numerical: Makefile
Only in /home/makerpm/nurbs++-3.0.11/examples/nurbs: .deps
Only in /home/makerpm/nurbs++-3.0.11/examples/nurbs: Makefile
diff -ur ./image/color.cpp /home/makerpm/nurbs++-3.0.11/image/color.cpp
--- ./image/color.cpp	2002-05-14 07:07:45.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/image/color.cpp	2009-01-24 03:06:00.000000000 +1100
@@ -50,7 +50,7 @@
   Color blackColor(0,0,0) ;
   */
 
-  double
+template<>  double
     Matrix<Color>::norm(void) {
 #ifdef USE_EXCEPTION
     throw MatrixErr();
@@ -63,7 +63,7 @@
   }
 
 #ifndef USING_VCC
-  int Matrix<Color>::read(char* filename,int r, int c) {
+ template<>  int Matrix<Color>::read(char* filename,int r, int c) {
     ifstream fin(filename) ;
     if(!fin) {
       resize(1,1) ;
@@ -89,7 +89,7 @@
   }
 #endif
 
-  int Vector<Color>::minIndex() const {
+template<>  int Vector<Color>::minIndex() const {
 #ifdef USE_EXCEPTION
     throw MatrixErr() ;
 #else
Only in /home/makerpm/nurbs++-3.0.11/image: color.lo
Only in /home/makerpm/nurbs++-3.0.11/image: color.o
Only in /home/makerpm/nurbs++-3.0.11/image: .deps
Only in /home/makerpm/nurbs++-3.0.11/image: filter_.lo
Only in /home/makerpm/nurbs++-3.0.11/image: filter_.o
diff -ur ./image/image.cpp /home/makerpm/nurbs++-3.0.11/image/image.cpp
--- ./image/image.cpp	2002-05-14 07:07:45.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/image/image.cpp	2009-01-24 03:06:00.000000000 +1100
@@ -55,9 +55,9 @@
 void MatrixImage<T>::drawLine(int i1, int j1, int i2, int j2, T color){
   int i,j ;
   double mx,b ;
-  if(i1<0 || j1<0 || i1>rows() || j1>=cols()  ){
+  if(i1<0 || j1<0 || i1>MatrixImage<T>::rows() || j1>=MatrixImage<T>::cols()  ){
 #ifdef USE_EXCEPTION
-    throw OutOfBound2D(i1,j1,0,rows()-1,0,cols()-1) ;
+    throw OutOfBound2D(i1,j1,0,MatrixImage<T>::rows()-1,0,MatrixImage<T>::cols()-1) ;
 #else
     Error error("MatrixImage<T>::drawLine") ;
     error << "Error in drawing line\n Invalid index ("<< i1 << ", " << j1 << ") to ( " << i2 << ", " << j2 << ") \n" ;
@@ -65,9 +65,9 @@
 #endif
     return ;
   }
-  if(i2 <0 || j2<0 || i2>rows() || j2>=cols() ){
+  if(i2 <0 || j2<0 || i2>MatrixImage<T>::rows() || j2>=MatrixImage<T>::cols() ){
 #ifdef USE_EXCEPTION
-    throw OutOfBound2D(i2,j2,0,rows()-1,0,cols()-1) ;
+    throw OutOfBound2D(i2,j2,0,MatrixImage<T>::rows()-1,0,MatrixImage<T>::cols()-1) ;
 #else
     Error error("MatrixImage<T>::drawLine") ;
     error << "Error in drawing line\n Invalid index ("<< i1 << ", " << j1 << ") to ( " << i2 << ", " << j2 << ") \n" ;
@@ -79,7 +79,7 @@
   // check if line is vertical
   if(j1==j2){
     for(i=minimum(i1,i2);i<=maximum(i1,i2);i++)
-     operator()(i,j1) = color ;
+    MatrixImage<T>:: operator()(i,j1) = color ;
     return ;
   }
   mx = (double)(i1-i2)/(double)(j1-j2) ;
@@ -88,13 +88,13 @@
     if(i1>i2){
       for(i=i1;i>=i2;i--){
 	j = int(((double)i-b)/mx) ;
-	operator()(i,j) = color ;
+	MatrixImage<T>::operator()(i,j) = color ;
       }
     }
     else{
       for(i=i1;i<=i2;i++){
 	j = (int)((i-b)/mx) ;
-	operator()(i,j) = color ;
+	MatrixImage<T>::operator()(i,j) = color ;
       }
     }
   }
@@ -102,13 +102,13 @@
     if(j1>j2){
       for(j=j1;j>=j2;j--){
 	i = (int)(mx*j+b) ;
-	operator()(i,j) = color ;
+	MatrixImage<T>::operator()(i,j) = color ;
       }
     }
     else{
       for(j=j1;j<=j2;j++){
 	i = (int)(mx*j+b) ;
-	operator()(i,j) = color ;
+	MatrixImage<T>::operator()(i,j) = color ;
       }
     }
   }
@@ -133,9 +133,9 @@
 void MatrixImage<T>::drawPoint(int i, int j, double r , T color){
   for(int y=i-int(ceil(r)) ; y<i+int(ceil(r)) ; y++)
     for(int x = j-int(ceil(r)) ; x<j+int(ceil(r)) ; x++){
-      if(y>=0 && y<rows() && x>=0 && x<cols()){
+      if(y>=0 && y<MatrixImage<T>::rows() && x>=0 && x<MatrixImage<T>::cols()){
 	if( ((y-i)*(y-i)+(x-j)*(x-j))<= r*r)
-	  operator()(y,x) = color ;
+	  MatrixImage<T>::operator()(y,x) = color ;
       }
     }
 }
@@ -153,14 +153,14 @@
 */
 template <class T>
 void MatrixImage<T>::store(Matrix<T>& a){
-  if(a.rows() != rows() || a.cols() != cols()) {
-    a.resize(rows(),cols()) ;
+  if(a.rows() != MatrixImage<T>::rows() || a.cols() != MatrixImage<T>::cols()) {
+    a.resize(MatrixImage<T>::rows(),MatrixImage<T>::cols()) ;
   }
   T *aptr, *bptr ;
   int size,i ;
   aptr = &a(0,0)-1 ;
-  bptr = m-1 ;
-  size = cols()*rows() ;
+  bptr = this->m-1 ;
+  size = MatrixImage<T>::cols()*MatrixImage<T>::rows() ;
   for(i=0;i<size;i++)
     *(++aptr) = *(++bptr) ;  
 }
Only in /home/makerpm/nurbs++-3.0.11/image: image_.lo
Only in /home/makerpm/nurbs++-3.0.11/image: image_.o
Only in /home/makerpm/nurbs++-3.0.11/image: libmatrixI.la
Only in /home/makerpm/nurbs++-3.0.11/image: .libs
Only in /home/makerpm/nurbs++-3.0.11/image: Makefile
Only in /home/makerpm/nurbs++-3.0.11/image: rec_filter_.lo
Only in /home/makerpm/nurbs++-3.0.11/image: rec_filter_.o
Only in /home/makerpm/nurbs++-3.0.11/include: Makefile
diff -ur ./include/plib_config.h /home/makerpm/nurbs++-3.0.11/include/plib_config.h
--- ./include/plib_config.h	2002-05-25 04:18:37.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/include/plib_config.h	2009-01-24 03:05:58.000000000 +1100
@@ -27,7 +27,7 @@
 
 // Define if you want the matrix to be in column order rather than row order.
 // Column ordering is used by fortran and OpenGL.
-#define COLUMN_ORDER 1
+/* #undef COLUMN_ORDER */
 
 // the name of the package
 #define PACKAGE "nurbs++"
@@ -39,7 +39,7 @@
 #define HAVE_NAMESPACE 1
 
 // Specify if OpenGL is present on this system
-#define WITH_OPENGL 1
+/* #undef WITH_OPENGL */
 
 // Specify if you are using Solaris with egcs
 /* #undef USING_GNU_SOLARIS */
@@ -54,7 +54,7 @@
 #define USING_LINUX 1
 
 // Specify if you have CppUnit installed
-#define HAS_CPPUNIT 1
+/* #undef HAS_CPPUNIT */
 
 // Specify if you have abs defined for the Complex type
 #define HAS_COMPLEX_ABS 1
Only in /home/makerpm/nurbs++-3.0.11/include: stamp-h1
Only in /home/makerpm/nurbs++-3.0.11/: libtool
Only in /home/makerpm/nurbs++-3.0.11/: Makefile
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray2d_char.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray2d_char.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray2d_complex.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray2d_complex.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray2d_coordinate.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray2d_coordinate.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray2d_double.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray2d_double.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray2d_float.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray2d_float.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray2d_hpoint.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray2d_hpoint.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray2d_int.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray2d_int.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray2d_point.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray2d_point.o
diff -ur ./matrix/barray2d_uchar.cpp /home/makerpm/nurbs++-3.0.11/matrix/barray2d_uchar.cpp
--- ./matrix/barray2d_uchar.cpp	2002-05-14 07:07:45.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/matrix/barray2d_uchar.cpp	2009-01-24 03:05:58.000000000 +1100
@@ -27,7 +27,7 @@
 
 namespace PLib {
 
-ostream& 
+template<> ostream& 
 Basic2DArray<unsigned char>::print(ostream& os) const
 {
   int i, j;
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray2d_uchar.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray2d_uchar.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray_char.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray_char.o
diff -ur ./matrix/barray_complex.cpp /home/makerpm/nurbs++-3.0.11/matrix/barray_complex.cpp
--- ./matrix/barray_complex.cpp	2002-05-14 07:07:45.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/matrix/barray_complex.cpp	2009-01-24 03:05:58.000000000 +1100
@@ -27,7 +27,7 @@
 
 namespace PLib {
 
-ostream&
+template<> ostream&
 BasicArray<Complex>::print(ostream& os)  const{
   const int iend = size();
   
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray_complex.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray_complex.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray_coordinate.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray_coordinate.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray_double.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray_double.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray_float.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray_float.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray_hpoint.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray_hpoint.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray_int.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray_int.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray_point.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray_point.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray_uchar.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray_uchar.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray_void.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: barray_void.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: coordinate.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: coordinate.o
diff -ur ./matrix/cvector.h /home/makerpm/nurbs++-3.0.11/matrix/cvector.h
--- ./matrix/cvector.h	2002-05-14 07:07:45.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/matrix/cvector.h	2009-01-24 03:05:58.000000000 +1100
@@ -54,10 +54,10 @@
     CVector(const BasicArray<T>& v) : Vector<T>(v), index(0)  {;}
     virtual ~CVector() {}
     
-    T& operator[](const int i) { return x[i%sze]; }
-    T  operator[](const int i) const   { return x[i%sze]; }
+    T& operator[](const int i) { return (this->x)[i%(this->sze)]; }
+    T  operator[](const int i) const   { return (this->x)[i%(this->sze)]; }
     
-    void put(T v) { x[index] = v ; index = (index+1)%sze; }
+    void put(T v) { (this->x)[index] = v ; index = (index+1)%(this->sze); }
     
   protected:
     int index ;
Only in /home/makerpm/nurbs++-3.0.11/matrix: cvector.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: cvector.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: .deps
Only in /home/makerpm/nurbs++-3.0.11/matrix: error.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: error.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: hpoint_nd.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: hpoint_nd.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: libmatrix.la
Only in /home/makerpm/nurbs++-3.0.11/matrix: .libs
Only in /home/makerpm/nurbs++-3.0.11/matrix: list.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: list.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: Makefile
diff -ur ./matrix/matrix_char.cpp /home/makerpm/nurbs++-3.0.11/matrix/matrix_char.cpp
--- ./matrix/matrix_char.cpp	2002-05-14 07:07:45.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/matrix/matrix_char.cpp	2009-01-24 03:05:58.000000000 +1100
@@ -27,7 +27,7 @@
 
 namespace PLib {
 
-  Matrix<char>&
+template<>  Matrix<char>&
     Matrix<char>::operator*=(double a)
     {
       char *p1 ;
@@ -40,7 +40,7 @@
       return *this ;
     }
   
-  Matrix<char>&
+template<>  Matrix<char>&
     Matrix<char>::operator+=(double a)
     {
       char *p1 ;
@@ -51,7 +51,7 @@
       return *this ;
     }
   
-  Matrix<char>&
+ template<>  Matrix<char>&
     Matrix<char>::operator-=(double a)
     {
       char *p1 ;
@@ -62,7 +62,7 @@
       return *this ;
     }
   
-  Matrix<char>&
+ template<>  Matrix<char>&
     Matrix<char>::operator/=(double a)
     {
       char *p1 ;
Only in /home/makerpm/nurbs++-3.0.11/matrix: matrix_char.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: matrix_char.o
diff -ur ./matrix/matrix_complex.cpp /home/makerpm/nurbs++-3.0.11/matrix/matrix_complex.cpp
--- ./matrix/matrix_complex.cpp	2002-05-25 03:25:49.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/matrix/matrix_complex.cpp	2009-01-24 03:05:58.000000000 +1100
@@ -27,7 +27,7 @@
 
 namespace PLib {
 
-  double Matrix<Complex>::norm(void){
+ template<>  double Matrix<Complex>::norm(void){
     int i,j ;
     double sumR, sumI, maxsum;
     int init=0 ;
Only in /home/makerpm/nurbs++-3.0.11/matrix: matrix_complex.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: matrix_complex.o
diff -ur ./matrix/matrix.cpp /home/makerpm/nurbs++-3.0.11/matrix/matrix.cpp
--- ./matrix/matrix.cpp	2002-05-14 07:07:45.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/matrix/matrix.cpp	2009-01-24 03:05:58.000000000 +1100
@@ -54,19 +54,19 @@
   if ( this == &a )
     return *this;
   
-  if ( a.rows() != rows() || a.cols() != cols() ){
-    resize(a.rows(),a.cols()) ;
+  if ( a.rows() !=Matrix<T>::rows() || a.cols() !=Matrix<T>::cols() ){
+    this->resize(a.rows(),a.cols()) ;
   }
   
-  int sze = rows()*cols() ;
+  int sze =(Matrix<T>::rows())*(Matrix<T>::cols()) ;
   T *ptr, *aptr ;
-  ptr = m-1 ;
+  ptr = this->m-1 ;
   aptr = a.m-1 ;
   
   for (i = sze; i > 0; --i)
     *(++ptr) = *(++aptr) ;
   
-  by_columns = a.by_columns;
+  this->by_columns = a.by_columns;
   
   return *this;
 }
@@ -100,10 +100,10 @@
 {
   int rwz,coz,i,j;
   
-  if ( rows() % a.rows() != 0 || cols() % a.cols() != 0 || rows() < a.rows() || cols() < a.cols() )
+  if (Matrix<T>::rows() % a.rows() != 0 ||Matrix<T>::cols() % a.cols() != 0 ||Matrix<T>::rows() < a.rows() ||Matrix<T>::cols() < a.cols() )
     {
 #ifdef USE_EXCEPTION
-      throw WrongSize2D(rows(),cols(),a.rows(),a.cols()) ;
+      throw WrongSize2D(Matrix<T>::rows(),Matrix<T>::cols(),a.rows(),a.cols()) ;
 #else
       Error error("Matrix<T>::submatrix");
       error << "Matrix and submatrix incommensurate" ;
@@ -111,13 +111,13 @@
 #endif
     }
   
-  if ( sr >= rows()/a.rows() || sr < 0 || sc >= cols()/a.cols() || sc < 0 )
+  if ( sr >=Matrix<T>::rows()/a.rows() || sr < 0 || sc >=Matrix<T>::cols()/a.cols() || sc < 0 )
     {
 #ifdef USE_EXCEPTION
-      throw OutOfBound2D(sr,sc,0,rows()/a.rows()-1,0,cols()/a.cols()-1) ;
+      throw OutOfBound2D(sr,sc,0,Matrix<T>::rows()/a.rows()-1,0,Matrix<T>::cols()/a.cols()-1) ;
 #else
       Error error("Matrix<T>::submatrix");
-      error << "Submatrix location out of bounds.\nrowblock " << sr << ", " << rows()/a.rows() << " colblock " << sc << ", " << a.cols() << endl ;
+      error << "Submatrix location out of bounds.\nrowblock " << sr << ", " <<Matrix<T>::rows()/a.rows() << " colblock " << sc << ", " << a.cols() << endl ;
       error.fatal() ;
 #endif
     }
@@ -127,13 +127,13 @@
 #ifdef COLUMN_ORDER
   for ( i = a.rows()-1; i >= 0; --i )
     for(j=a.cols()-1;j>=0;--j)
-      elem(i+rwz,j+coz) = a(i,j) ;
+      this->elem(i+rwz,j+coz) = a(i,j) ;
 #else
   T *ptr, *aptr ;
   aptr = a.m - 1;
   for ( i = a.rows()-1; i >= 0; --i )
     {
-      ptr = &m[(i+rwz)*cols()+coz]-1 ;
+      ptr = &(this->m)[(i+rwz)*Matrix<T>::cols()+coz]-1 ;
       for ( j = a.cols(); j > 0; --j)
 	*(++ptr) = *(++aptr) ;
     }  
@@ -159,7 +159,7 @@
   // Assign matrix a to this matrix at (i,j)
   int i, j;
   
-  if ( (rw + a.rows()) > rows() || ( cl + a.cols()) > cols()) {
+  if ( (rw + a.rows()) >Matrix<T>::rows() || ( cl + a.cols()) >Matrix<T>::cols()) {
 #ifdef USE_EXCEPTION
     throw MatrixErr();
 #else
@@ -172,12 +172,12 @@
 #ifdef COLUMN_ORDER
   for(i=0;i<a.rows();++i)
     for(j=0;j<a.cols();++j)
-      elem(i+rw,j+cl) = a(i,j) ;
+      this->elem(i+rw,j+cl) = a(i,j) ;
 #else
   T *pptr,*aptr ;
   aptr = a.m-1 ;
   for ( i = 0; i<a.rows(); ++i) {
-    pptr = &m[(i+rw)*cols()+cl]-1 ;
+    pptr = &(this->m)[(i+rw)*Matrix<T>::cols()+cl]-1 ;
     for ( j = 0; j < a.cols(); ++j)
       *(++pptr) = *(++aptr);
   }
@@ -194,7 +194,7 @@
 
   \param rw  the index of the row 
   \param cl  the index of the column
-  \param nr  the number of rows() of the matrix to generate
+  \param nr  the number ofMatrix<T>::rows() of the matrix to generate
   \param nc  the number of coluns of the matrix to generate
 
   \return the matrix of size \a (nr,nc) starting at index \a (rw,cl).
@@ -208,7 +208,7 @@
 Matrix<T> Matrix<T>::get(int rw, int cl, int nr, int nc) const
 {
   Matrix<T> getmat(nr,nc) ;
-  if ( (rw+nr) > rows() || (cl+nc) > cols()) {
+  if ( (rw+nr) >Matrix<T>::rows() || (cl+nc) >Matrix<T>::cols()) {
 #ifdef USE_EXCEPTION
     throw MatrixErr();
 #else
@@ -223,12 +223,12 @@
 #ifdef COLUMN_ORDER
   for(i=0;i<nr;++i)
     for(j=0;j<nc;++j)
-      getmat(i,j) = elem(i+rw,j+cl) ;
+      getmat(i,j) = this->elem(i+rw,j+cl) ;
 #else
   T *pptr,*aptr ;
   aptr = getmat.m-1;
   for (i = 0; i < nr; ++i) {
-    pptr = &m[(i+rw)*cols()+cl]-1 ;
+    pptr = &(this->m)[(i+rw)*Matrix<T>::cols()+cl]-1 ;
     for ( j = 0; j < nc; ++j)
       *(++aptr) = *(++pptr) ;
   }
@@ -252,11 +252,11 @@
   double sum, maxsum;
   int init=0 ;
   T *pptr ;
-  pptr = m-1 ;
+  pptr = this->m-1 ;
   maxsum = 0 ; // Silence the warning message
-  for(i=0;i<rows();++i){
+  for(i=0;i<Matrix<T>::rows();++i){
     sum = 0 ;
-    for ( j = 0; j < cols(); ++j) 
+    for ( j = 0; j <Matrix<T>::cols(); ++j) 
       sum += *(++pptr) ;
     if(init)
       maxsum = (maxsum>sum) ? maxsum : sum;
@@ -285,12 +285,12 @@
 {
   int i, iend;
   
-  iend = rows();
-  if ( iend > cols() )
-    iend = cols();
+  iend =Matrix<T>::rows();
+  if ( iend >Matrix<T>::cols() )
+    iend =Matrix<T>::cols();
   
   for (i = iend-1; i >=0; --i)
-    elem(i,i) = a;
+    this->elem(i,i) = a;
 
 }
 
@@ -308,10 +308,10 @@
 template <class T>
 Vector<T> Matrix<T>::getDiag(){
   int i, iend;
-  Vector<T> vec(minimum(rows(),cols())) ;
-  iend = minimum(rows(),cols());
+  Vector<T> vec(minimum(Matrix<T>::rows(),Matrix<T>::cols())) ;
+  iend = minimum(Matrix<T>::rows(),Matrix<T>::cols());
   for (i = iend-1; i >=0; --i)
-      vec[i] = elem(i,i);
+      vec[i] = this->elem(i,i);
   return vec ;
 }
 
@@ -328,8 +328,8 @@
 Matrix<T>& Matrix<T>::operator+=(double a)
 {
   T *p1 ;
-  p1 = m-1 ;
-  const int size = rows()*cols() ;
+  p1 = this->m-1 ;
+  const int size =Matrix<T>::rows()*Matrix<T>::cols() ;
   for(int i=size; i>0; --i)
     *(++p1) += a ;  
   return *this ;
@@ -348,8 +348,8 @@
 Matrix<T>& Matrix<T>::operator-=(double a)
 {
   T *p1 ;
-  p1 = m-1 ;
-  const int size = rows()*cols() ;
+  p1 = this->m-1 ;
+  const int size =Matrix<T>::rows()*Matrix<T>::cols() ;
   for(int i=size; i>0; --i)
     *(++p1) -= a ;  
   return *this ;
@@ -368,8 +368,8 @@
 Matrix<T>& Matrix<T>::operator*=(double a)
 {
   T *p1 ;
-  p1 = m-1 ;
-  const int size = rows()*cols() ;
+  p1 = this->m-1 ;
+  const int size =Matrix<T>::rows()*Matrix<T>::cols() ;
   for(int i=size; i>0; --i)
     *(++p1) *= a ;  
   return *this ;
@@ -388,8 +388,8 @@
 Matrix<T>& Matrix<T>::operator/=(double a)
 {
   T *p1 ;
-  p1 = m-1 ;
-  const int size = rows()*cols() ;
+  p1 = this->m-1 ;
+  const int size =Matrix<T>::rows()*Matrix<T>::cols() ;
   for(int i=size; i>0; --i)
     *(++p1) /= a ;  
   return *this ;
@@ -408,16 +408,16 @@
 template <class T> 
 Matrix<T>& Matrix<T>::operator+=(const Matrix<T> &a)
 {
-  if ( a.rows() != rows() || a.cols() != cols() )
+  if ( a.rows() !=Matrix<T>::rows() || a.cols() !=Matrix<T>::cols() )
     {
 #ifdef USE_EXCEPTION
-      throw WrongSize2D(rows(),cols(),a.rows(),a.cols());
+      throw WrongSize2D(Matrix<T>::rows(),Matrix<T>::cols(),a.rows(),a.cols());
 #else
       Error error("Matrix<T>::operator+=") ;
-      if ( rows() != a.rows() )
-	error << "Matrices are of diferent size, a.rows() = " << rows() << " and b.rows() = " << a.rows() << endl ;
-      if ( cols() != a.cols())
-	error << "Matrices are of diferent size, a.cols() = " << cols() << " and b.cols() = " << a.cols() << endl ;
+      if (Matrix<T>::rows() != a.rows() )
+	error << "Matrices are of diferent size, a.rows() = " <<Matrix<T>::rows() << " and b.rows() = " << a.rows() << endl ;
+      if (Matrix<T>::cols() != a.cols())
+	error << "Matrices are of diferent size, a.cols() = " <<Matrix<T>::cols() << " and b.cols() = " << a.cols() << endl ;
       error.fatal() ;
 #endif
     }
@@ -425,8 +425,8 @@
   int i, sze ;
   T *aptr,*sptr ;
   aptr = a.m - 1 ;
-  sptr = m - 1 ;
-  sze = rows()*cols() ;
+  sptr = this->m - 1 ;
+  sze =Matrix<T>::rows()*Matrix<T>::cols() ;
   for (i = sze; i > 0; --i){
       *(++sptr) += *(++aptr) ;
   }
@@ -468,16 +468,16 @@
 template <class T> 
 Matrix<T>& Matrix<T>::operator-=(const Matrix<T> &a)
 {
-  if ( a.rows() != rows() || a.cols() != cols() )
+  if ( a.rows() !=Matrix<T>::rows() || a.cols() !=Matrix<T>::cols() )
     {
 #ifdef USE_EXCEPTION
-      throw WrongSize2D(rows(),cols(),a.rows(),a.cols());
+      throw WrongSize2D(Matrix<T>::rows(),Matrix<T>::cols(),a.rows(),a.cols());
 #else
       Error error("Matrix<T>::operator-=") ;
-      if ( rows() != a.rows() )
-	error << "Matrices are of diferent size, a.rows() = " << rows() << " and b.rows() = " << a.rows() << endl ;
-      if ( cols() != a.cols())
-	error << "Matrices are of diferent size, a.cols() = " << cols() << " and b.cols() = " << a.cols() << endl ;
+      if (Matrix<T>::rows() != a.rows() )
+	error << "Matrices are of diferent size, a.rows() = " <<Matrix<T>::rows() << " and b.rows() = " << a.rows() << endl ;
+      if (Matrix<T>::cols() != a.cols())
+	error << "Matrices are of diferent size, a.cols() = " <<Matrix<T>::cols() << " and b.cols() = " << a.cols() << endl ;
       error.fatal() ;
 #endif
     }
@@ -485,8 +485,8 @@
   int i, size;
   T *aptr,*sptr ;
   aptr = a.m - 1 ;
-  sptr = m - 1 ;
-  size = rows()*cols() ;
+  sptr = this->m - 1 ;
+  size =Matrix<T>::rows()*Matrix<T>::cols() ;
   for (i = size; i > 0; --i){
       *(++sptr) -= *(++aptr) ;
   }
@@ -742,14 +742,14 @@
 template <class T>
 T Matrix<T>::trace() const
 {
-  int size = rows();
+  int size =Matrix<T>::rows();
   T sum = (T)0;
   
-  if ( size > cols() )
-    size = cols();
+  if ( size >Matrix<T>::cols() )
+    size =Matrix<T>::cols();
   
   for (int d = 0; d < size; ++d)
-    sum += elem(d,d) ;
+    sum += this->elem(d,d) ;
   
   return sum;
 }
@@ -770,12 +770,12 @@
 template <class T>
 Matrix<T> Matrix<T>::herm() const
 {
-  int i, j, r = cols(), c = rows();
+  int i, j, r =Matrix<T>::cols(), c =Matrix<T>::rows();
   Matrix<T> adj(r,c);
   
   for (i = 0; i < r; ++i)
     for (j = 0; j < c; ++j)
-      adj.elem(i,j) = elem(j,i) ;
+      adj.elem(i,j) = this->elem(j,i) ;
 
   return adj;
 
@@ -794,11 +794,11 @@
 template <class T>
 Matrix<T> Matrix<T>::flop() const
 {					
-  Matrix<T> f(rows(),cols()) ;
-  for(int i=rows()-1;i>=0;--i)
-    for(int j=cols()-1;j>=0;--j)
+  Matrix<T> f(Matrix<T>::rows(),Matrix<T>::cols()) ;
+  for(int i=Matrix<T>::rows()-1;i>=0;--i)
+    for(int j=Matrix<T>::cols()-1;j>=0;--j)
       {
-	f(i,j) = elem(i,cols()-j-1);
+	f(i,j) = this->elem(i,Matrix<T>::cols()-j-1);
       }
   return f; 
 }
@@ -817,13 +817,13 @@
 {					
   // same as hermitian for real Matrix<T>
   int i, j;
-  const int& r = cols();
-  const int& c = rows();
+  const int& r =Matrix<T>::cols();
+  const int& c =Matrix<T>::rows();
   Matrix<T> adj(r,c);
   
   for (i = r-1; i >=0; --i)
     for (j = c-1; j >=0; --j)
-      adj.elem(i,j) = elem(j,i) ;
+      adj.elem(i,j) = this->elem(j,i) ;
   
   
   return adj; 
@@ -833,7 +833,7 @@
 /*!
   \brief read a matrix file
   Reads a matrix file. The format of a file is
-{\tt rows() cols() data...}, where rows() and cols() are int and data is a vector of the matrix type.
+{\ttMatrix<T>::rows()Matrix<T>::cols() data...}, whereMatrix<T>::rows() andMatrix<T>::cols() are int and data is a vector of the matrix type.
   \param filename  the name of the file to read
   \return 1 if reading the file was successfull, 0 otherwise
   \warning
@@ -844,7 +844,7 @@
 int Matrix<T>::read(char* filename) {
   ifstream fin(filename) ;
   if(!fin) {
-    resize(1,1) ;
+    this->resize(1,1) ;
     return 0 ;
   }
   int r,c ;
@@ -855,8 +855,8 @@
   if(r) return 0 ;
   if(!fin.read((char*)&r,sizeof(int))) return 0 ;
   if(!fin.read((char*)&c,sizeof(int))) return 0 ;
-  resize(r,c) ;
-  if(!fin.read((char*)m,sizeof(T)*r*c)) return 0 ;
+  this->resize(r,c) ;
+  if(!fin.read((char*)(this->m),sizeof(T)*r*c)) return 0 ;
 
   delete []type ;
   return 1 ;
@@ -866,7 +866,7 @@
   \brief read a raw file containing a matrix of size $(r,c)$
   Reads a file containing raw data of a matrix of size $(r,c)$.
   \param filename  the name of the file to read
-                      r  the number of rows() 
+                      r  the number ofMatrix<T>::rows() 
                       c  the number of columns
   \return 1 if reading the file was successfull, 0 otherwise
   \warning
@@ -877,11 +877,11 @@
 int Matrix<T>::read(char* filename,int r, int c) {
   ifstream fin(filename) ;
   if(!fin) {
-    resize(1,1) ;
+    this->resize(1,1) ;
     return 0 ;
   }
-  resize(r,c) ;
-  if(!fin.read((char*)m,sizeof(T)*r*c)) return 0 ;
+  this->resize(r,c) ;
+  if(!fin.read((char*)(this->m),sizeof(T)*r*c)) return 0 ;
 
   return 1 ;
 }
@@ -890,7 +890,7 @@
 /*!
   \brief write a matrix into a Matrix file
   Writes a matrix file. The format of the file is
-               {\tt rows() cols() data...}, where rows() and cols() are int and data 
+               {\ttMatrix<T>::rows()Matrix<T>::cols() data...}, whereMatrix<T>::rows() andMatrix<T>::cols() are int and data 
 	       is a vector of the matrix type.
   \param filename  the name of the file to write to
   \return
@@ -904,11 +904,11 @@
   if(!fout)
     return 0 ;
   int r,c ;
-  r = rows() ; c = cols() ;
+  r = Matrix<T>::rows() ; c =Matrix<T>::cols() ;
   if(!fout.write((char*)&"matrix",sizeof(char)*6)) return 0 ;
   if(!fout.write((char*)&r,sizeof(int))) return 0 ;
   if(!fout.write((char*)&c,sizeof(int))) return 0 ;
-  if(!fout.write((char*)m,sizeof(T)*r*c)) return 0 ;
+  if(!fout.write((char*)(this->m),sizeof(T)*r*c)) return 0 ;
   return 1;
 }
 
@@ -927,7 +927,7 @@
   ofstream fout(filename) ;
   if(!fout)
     return 0 ;
-  if(!fout.write((char*)m,sizeof(T)*rows()*cols())) return 0 ;
+  if(!fout.write((char*)(this->m),sizeof(T)*(Matrix<T>::rows())*(Matrix<T>::cols()))) return 0 ;
   return 1;
 }
 
diff -ur ./matrix/matrix_double.cpp /home/makerpm/nurbs++-3.0.11/matrix/matrix_double.cpp
--- ./matrix/matrix_double.cpp	2002-05-14 07:07:45.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/matrix/matrix_double.cpp	2009-01-24 03:05:58.000000000 +1100
@@ -27,7 +27,7 @@
 
 namespace PLib {
   
-  void Matrix<double>::qSort(){
+  template<> void Matrix<double>::qSort(){
     qsort((char*)m,rows()*cols(),sizeof(double),compareDouble) ;
   }
 
Only in /home/makerpm/nurbs++-3.0.11/matrix: matrix_double.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: matrix_double.o
diff -ur ./matrix/matrix_float.cpp /home/makerpm/nurbs++-3.0.11/matrix/matrix_float.cpp
--- ./matrix/matrix_float.cpp	2002-05-14 07:07:45.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/matrix/matrix_float.cpp	2009-01-24 03:05:58.000000000 +1100
@@ -27,7 +27,7 @@
 
 namespace PLib {
   
-  void Matrix<float>::qSort(){
+  template<> void Matrix<float>::qSort(){
     qsort((char*)m,rows()*cols(),sizeof(float),compareFloat) ;
   }
 
Only in /home/makerpm/nurbs++-3.0.11/matrix: matrix_float.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: matrix_float.o
diff -ur ./matrix/matrix_hpoint.cpp /home/makerpm/nurbs++-3.0.11/matrix/matrix_hpoint.cpp
--- ./matrix/matrix_hpoint.cpp	2002-05-14 07:07:45.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/matrix/matrix_hpoint.cpp	2009-01-24 03:05:58.000000000 +1100
@@ -27,7 +27,7 @@
 
 namespace PLib {
 
-  double
+template<>  double
     Matrix<HPoint3Df>::norm(void) {
     int i,j ;
     double sumX, sumY, sumZ, sumW, maxsum;
@@ -58,7 +58,7 @@
   }
   
   
-  double
+ template<>  double
     Matrix<HPoint3Dd>::norm(void) {
     int i,j ;
     double sumX, sumY, sumZ, sumW, maxsum;
@@ -89,7 +89,7 @@
   }
   
   
-  double
+ template<>  double
     Matrix<HPoint2Df>::norm(void) {
     int i,j ;
     double sumX, sumY, sumZ, sumW, maxsum;
@@ -119,7 +119,7 @@
     return sqrt(maxsum);
   }
   
-  double
+ template<>  double
     Matrix<HPoint2Dd>::norm(void) {
     int i,j ;
     double sumX, sumY, sumZ, sumW, maxsum;
Only in /home/makerpm/nurbs++-3.0.11/matrix: matrix_hpoint.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: matrix_hpoint.o
diff -ur ./matrix/matrix_int.cpp /home/makerpm/nurbs++-3.0.11/matrix/matrix_int.cpp
--- ./matrix/matrix_int.cpp	2002-05-14 07:07:45.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/matrix/matrix_int.cpp	2009-01-24 03:05:58.000000000 +1100
@@ -29,11 +29,11 @@
 
 namespace PLib {
 
-  void Matrix<int>::qSort(){
-    qsort((char*)m,rows()*cols(),sizeof(int),compareInt) ;
+template<>  void Matrix<int>::qSort(){
+    qsort((char*)m,Matrix<int>::rows()*Matrix<int>::cols(),sizeof(int),compareInt) ;
   }
   
-  Matrix<int>&
+template<>  Matrix<int>&
     Matrix<int>::operator*=(double a)
     {
       int *p1 ;
@@ -46,7 +46,7 @@
       return *this ;
     }
   
-  Matrix<int>&
+template<>  Matrix<int>&
     Matrix<int>::operator+=(double a)
     {
       int *p1 ;
@@ -57,7 +57,7 @@
       return *this ;
     }
 
-  Matrix<int>&
+template<>  Matrix<int>&
     Matrix<int>::operator-=(double a)
     {
       int *p1 ;
@@ -68,7 +68,7 @@
       return *this ;
     }
   
-  Matrix<int>&
+template<>  Matrix<int>&
     Matrix<int>::operator/=(double a)
     {
       int *p1 ;
Only in /home/makerpm/nurbs++-3.0.11/matrix: matrix_int.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: matrix_int.o
diff -ur ./matrix/matrix_point.cpp /home/makerpm/nurbs++-3.0.11/matrix/matrix_point.cpp
--- ./matrix/matrix_point.cpp	2002-05-14 07:07:45.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/matrix/matrix_point.cpp	2009-01-24 03:05:58.000000000 +1100
@@ -27,7 +27,7 @@
 
 namespace PLib {
 
-  double
+template<>  double
     Matrix<Point3Df>::norm(void) {
     int i,j ;
     double sumX, sumY, sumZ, maxsum;
@@ -55,7 +55,7 @@
     return sqrt(maxsum);
   }
   
-  double
+template<>  double
     Matrix<Point3Dd>::norm(void) {
     int i,j ;
     double sumX, sumY, sumZ, maxsum;
@@ -83,7 +83,7 @@
     return sqrt(maxsum);
   }
   
-  double
+template<>  double
     Matrix<Point2Df>::norm(void) {
     int i,j ;
     double sumX, sumY, sumZ, maxsum;
@@ -111,7 +111,7 @@
     return sqrt(maxsum);
   }
 
-  double
+template<>  double
     Matrix<Point2Dd>::norm(void) {
     int i,j ;
     double sumX, sumY, sumZ, maxsum;
Only in /home/makerpm/nurbs++-3.0.11/matrix: matrix_point.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: matrix_point.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: matrixTool.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: matrixTool.o
diff -ur ./matrix/matrix_uchar.cpp /home/makerpm/nurbs++-3.0.11/matrix/matrix_uchar.cpp
--- ./matrix/matrix_uchar.cpp	2002-05-14 07:07:45.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/matrix/matrix_uchar.cpp	2009-01-24 03:05:58.000000000 +1100
@@ -27,7 +27,7 @@
 
 namespace PLib {
 
-  Matrix<unsigned char>&
+template<>  Matrix<unsigned char>&
     Matrix<unsigned char>::operator*=(double a)
     {
       unsigned char *p1 ;
@@ -40,7 +40,7 @@
       return *this ;
     }
   
-  Matrix<unsigned char>&
+template<>  Matrix<unsigned char>&
     Matrix<unsigned char>::operator+=(double a)
     {
       unsigned char *p1 ;
@@ -52,7 +52,7 @@
     }
   
   
-  Matrix<unsigned char>&
+ template<>  Matrix<unsigned char>&
     Matrix<unsigned char>::operator-=(double a)
     {
       unsigned char *p1 ;
@@ -64,7 +64,7 @@
     }
   
   
-  Matrix<unsigned char>&
+ template<>  Matrix<unsigned char>&
     Matrix<unsigned char>::operator/=(double a)
     {
       unsigned char *p1 ;
Only in /home/makerpm/nurbs++-3.0.11/matrix: matrix_uchar.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: matrix_uchar.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: point_nd.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: point_nd.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: vector_char.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: vector_char.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: vector_complex.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: vector_complex.o
diff -ur ./matrix/vector.cpp /home/makerpm/nurbs++-3.0.11/matrix/vector.cpp
--- ./matrix/vector.cpp	2002-05-14 07:07:45.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/matrix/vector.cpp	2009-01-24 03:05:58.000000000 +1100
@@ -51,16 +51,16 @@
   if(this==&b)
     return *this ;
 
-  if ( n() != b.n())
+  if ( this->n() != b.n())
     {
-      resize(b.n()) ;
+      this->resize(b.n()) ;
     }
 
-  sze = b.n() ;
+  this->sze = b.n() ;
   T *pa, *pb ;
-  pa = x-1 ;
+  pa = this->x-1 ;
   pb = b.x-1 ;
-  for(int i=n();i>0;--i){
+  for(int i=this->n();i>0;--i){
     *(++pa) = *(++pb) ;
   }
   return *this;
@@ -79,13 +79,13 @@
 template <class T>
 Vector<T>& Vector<T>::operator=(const BasicArray<T> &b)
 {
-  if ( size() != b.size())
+  if ( this->size() != b.size())
     {
-      resize(b.size()) ;
+      this->resize(b.size()) ;
     }
   T *ptr ;
-  ptr = x - 1 ;
-  for(int i=size()-1;i>=0;--i)
+  ptr = this->x - 1 ;
+  for(int i=this->size()-1;i>=0;--i)
      *(++ptr) = b[i] ;
 
   return *this;
@@ -105,9 +105,9 @@
 template <class T>
 T Vector<T>::operator=(const T d)
 {
-  const int sz = size(); 
+  const int sz = this->size(); 
   T *ptr ;
-  ptr = x-1 ;
+  ptr = this->x-1 ;
   for (int i = sz; i > 0; --i)
     *(++ptr) = d ;
 
@@ -130,19 +130,19 @@
 template <class T>
 Vector<T>& Vector<T>::operator+=(const Vector<T> &a)
 {
-  if ( a.size() != size())
+  if ( a.size() != this->size())
     {
 #ifdef USE_EXCEPTION
-      throw WrongSize(size(),a.size()) ;
+      throw WrongSize(this->size(),a.size()) ;
 #else
       Error error("Vector<T>::operator+=(Vector<T>&)");
       error << "Vector<T> a += Vector<T> b different sizes, a = " << size() << ", b = " << a.size() ;
       error.fatal() ;
 #endif
     }
-  const int sz = size();
+  const int sz = this->size();
   T *ptr,*aptr ;
-  ptr = x-1 ;
+  ptr = this->x-1 ;
   aptr = a.x-1 ;
   for (int i = sz; i >0; --i)
     *(++ptr) += *(++aptr) ;
@@ -165,10 +165,10 @@
 template <class T>
 Vector<T>& Vector<T>::operator-=(const Vector<T> &a)
 {
-  if ( a.size() != size())
+  if ( a.size() != this->size())
     {
 #ifdef USE_EXCEPTION
-      throw WrongSize(size(),a.size()) ;
+      throw WrongSize(this->size(),a.size()) ;
 #else
       Error error("Vector<T>::operator-=(Vector<T>&)");
       error << "Vector<T> a -= Vector<T> b different sizes, a = " << size() << ", b = " << a.size() ;
@@ -176,9 +176,9 @@
 #endif
     }
   
-  const int sz = size(); 
+  const int sz = this->size(); 
   T *ptr,*aptr ;
-  ptr = x-1 ;
+  ptr = this->x-1 ;
   aptr = a.x-1 ;
   for (int i = sz; i > 0; --i)
     *(++ptr) -= *(++aptr) ;
@@ -391,7 +391,7 @@
     }
 
   T *aptr,*bptr ;
-  aptr = &x[i]-1 ;
+  aptr = &(this->x)[i]-1 ;
   bptr = b.x-1 ;
   for ( int j = b.rows(); j > 0; --j)
       *(++aptr) = *(++bptr) ;
@@ -429,7 +429,7 @@
 
   Vector<T> subvec(l) ;
   T *aptr, *bptr ;
-  aptr = &x[i] - 1 ;
+  aptr = &(this->x)[i] - 1 ;
   bptr = subvec.x -1 ;
   for ( int j = l; j > 0; --j)
     *(++bptr) = *(++aptr) ;
@@ -449,12 +449,12 @@
 */
 template <class T>
 int Vector<T>::minIndex() const {
-  T min = x[0] ;
+  T min = this->x[0] ;
   int index = 0 ;
 
-  for(int i=1;i<n();i++){
-    if(x[i]<=min){
-      min = x[i] ;
+  for(int i=1;i<this->n();i++){
+    if(this->x[i]<=min){
+      min = this->x[i] ;
       index = i ;
     }
   }
@@ -523,12 +523,12 @@
   T a ;
   T *v1,*v2  ;
 
-  ir = sze-1 ;
+  ir = this->sze-1 ;
   l = 0 ;
   
   while(1){
     if(ir-l<M){ // perform an insertion sort when the array is small enough
-      v1 = &x[l] ;
+      v1 = &(this->x)[l] ;
       for(j=l+1;j<=ir;++j){
 	a = *(++v1) ;
 	v2 = v1 ;
@@ -547,31 +547,31 @@
     }
     else{
       k=(l+ir) >> 1 ;
-      swap(x[k],x[l+1]) ;
-      if(x[l+1] > x[ir]){
-	swap(x[l+1],x[ir]) ;
+      swap((this->x)[k],(this->x)[l+1]) ;
+      if(this->x[l+1] > this->x[ir]){
+	swap((this->x)[l+1],(this->x)[ir]) ;
       }
-      if(x[l]> x[ir]){
-	swap(x[l],x[ir]) ;
+      if((this->x)[l]> (this->x)[ir]){
+	swap(this->x[l],this->x[ir]) ;
       }
-      if(x[l+1] > x[l]){
-	swap(x[l+1],x[l]) ;
+      if(this->x[l+1] > this->x[l]){
+	swap(this->x[l+1],this->x[l]) ;
       }
       i=l+1 ;
       j=ir ;
-      a=x[l] ;
-      v1 = &x[i] ;
-      v2 = &x[j] ;
+      a=this->x[l] ;
+      v1 = &(this->x)[i] ;
+      v2 = &(this->x)[j] ;
       while(1){
 	while(*v1 < a) { ++i ; ++v1 ; }
 	while(*v2 > a) { --j ; --v2 ; }
 	if(j<i) break ;
 	if(*v1 == *v2)  // both are equal to a...
 	  break ;
-	swap(x[i],x[j]) ;
+	swap(this->x[i],this->x[j]) ;
       }
-      x[l] = x[j] ;
-      x[j] = a ;
+      this->x[l] = this->x[j] ;
+      this->x[j] = a ;
       jstack += 2 ;
       if(jstack>=Nstack){
 	istack.resize(istack.n()+Nstack) ; // increase the vector size
@@ -618,10 +618,10 @@
   int jstack=0;
   T a ;
 
-  ir = sze-1 ;
+  ir = this->sze-1 ;
   l = 0 ;
   
-  index.resize(sze) ;
+  index.resize(this->sze) ;
   for(i=0;i<index.n();++i)
     index[i] = i ;
 
@@ -629,9 +629,9 @@
     if(ir-l<M){ // perform an insertion sort when the array is small enough
       for(j=l+1;j<=ir;++j){
 	indext = index[j] ;
-	a = x[indext] ;
+	a = this->x[indext] ;
 	for(i=j-1;i>=0;--i){
-	  if(x[index[i]] <= a) break ;
+	  if(this->x[index[i]] <= a) break ;
 	  index[i+1] = index[i] ;
 	}
 	index[i+1] = indext ;
@@ -643,24 +643,24 @@
     else{
       k=(l+ir) >> 1 ;
       swap(index[k],index[l+1]) ;
-      if(x[index[l+1]] > x[index[ir]]){
+      if(this->x[index[l+1]] > this->x[index[ir]]){
 	swap(index[l+1],index[ir]) ;
       }
-      if(x[index[l]]> x[index[ir]]){
+      if(this->x[index[l]]> this->x[index[ir]]){
 	swap(index[l],index[ir]) ;
       }
-      if(x[index[l+1]] > x[index[l]]){
+      if(this->x[index[l+1]] > this->x[index[l]]){
 	swap(index[l+1],index[l]) ;
       }
       i=l+1 ;
       j=ir ;
       indext = index[l] ;
-      a=x[indext] ;
+      a=this->x[indext] ;
       while(1){
-	while(x[index[i]] < a) { ++i ; }
-	while(x[index[j]] > a) { --j ; }
+	while(this->x[index[i]] < a) { ++i ; }
+	while(this->x[index[j]] > a) { --j ; }
 	if(j<i) break ;
-	if(x[index[i]] == x[index[j]])
+	if(this->x[index[i]] == this->x[index[j]])
 	  break ;
 	swap(index[i],index[j]) ;
       }
diff -ur ./matrix/vector_double.cpp /home/makerpm/nurbs++-3.0.11/matrix/vector_double.cpp
--- ./matrix/vector_double.cpp	2002-05-14 07:07:45.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/matrix/vector_double.cpp	2009-01-24 03:05:58.000000000 +1100
@@ -27,7 +27,7 @@
 
 namespace PLib {
 
-  void Vector<double>::qSortStd(){
+  template<> void Vector<double>::qSortStd(){
     qsort((char*)memory(),n(),sizeof(float),compareDouble) ;
   }
   
Only in /home/makerpm/nurbs++-3.0.11/matrix: vector_double.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: vector_double.o
diff -ur ./matrix/vector_float.cpp /home/makerpm/nurbs++-3.0.11/matrix/vector_float.cpp
--- ./matrix/vector_float.cpp	2002-05-14 07:07:45.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/matrix/vector_float.cpp	2009-01-24 03:05:58.000000000 +1100
@@ -27,7 +27,7 @@
 
 namespace PLib {
 
-  void Vector<float>::qSortStd(){
+  template<> void Vector<float>::qSortStd(){
     qsort((char*)memory(),n(),sizeof(float),compareFloat) ;
   }
 
Only in /home/makerpm/nurbs++-3.0.11/matrix: vector_float.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: vector_float.o
diff -ur ./matrix/vector.h /home/makerpm/nurbs++-3.0.11/matrix/vector.h
--- ./matrix/vector.h	2002-05-14 07:07:45.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/matrix/vector.h	2009-01-24 03:05:58.000000000 +1100
@@ -69,7 +69,7 @@
   {
   public:
     int rows() const //!< a reference to the size of the vector
-      { return sze ;}
+      { return this->sze ;}
     Vector() : BasicArray<T>(1) {} //!< Basic constructor
     Vector(const int r) : BasicArray<T>(r) {}
     Vector(const Vector<T>& v) : BasicArray<T>(v) {}
Only in /home/makerpm/nurbs++-3.0.11/matrix: vector_hpoint.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: vector_hpoint.o
diff -ur ./matrix/vector_int.cpp /home/makerpm/nurbs++-3.0.11/matrix/vector_int.cpp
--- ./matrix/vector_int.cpp	2002-05-14 07:07:45.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/matrix/vector_int.cpp	2009-01-24 03:05:58.000000000 +1100
@@ -27,7 +27,7 @@
 
 namespace PLib {
 
-  void Vector<int>::qSortStd(){
+ template<>  void Vector<int>::qSortStd(){
     qsort((char*)memory(),n(),sizeof(int),compareInt) ;
   }
   
Only in /home/makerpm/nurbs++-3.0.11/matrix: vector_int.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: vector_int.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: vector_point.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: vector_point.o
Only in /home/makerpm/nurbs++-3.0.11/matrix: vector_uchar.lo
Only in /home/makerpm/nurbs++-3.0.11/matrix: vector_uchar.o
Only in /home/makerpm/nurbs++-3.0.11/numerical: chebexp_.lo
Only in /home/makerpm/nurbs++-3.0.11/numerical: chebexp_.o
Only in /home/makerpm/nurbs++-3.0.11/numerical: .deps
Only in /home/makerpm/nurbs++-3.0.11/numerical: fft_.lo
Only in /home/makerpm/nurbs++-3.0.11/numerical: fft_.o
Only in /home/makerpm/nurbs++-3.0.11/numerical: intccq_.lo
Only in /home/makerpm/nurbs++-3.0.11/numerical: intccq_.o
Only in /home/makerpm/nurbs++-3.0.11/numerical: libmatrixN.la
Only in /home/makerpm/nurbs++-3.0.11/numerical: .libs
Only in /home/makerpm/nurbs++-3.0.11/numerical: Makefile
diff -ur ./numerical/matrixMat.cpp /home/makerpm/nurbs++-3.0.11/numerical/matrixMat.cpp
--- ./numerical/matrixMat.cpp	2002-05-14 07:07:45.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/numerical/matrixMat.cpp	2009-01-24 03:05:59.000000000 +1100
@@ -48,9 +48,9 @@
 template <class T>
 LUMatrix<T>& LUMatrix<T>::operator=(const LUMatrix<T>& a){
   resize(a.rows(),a.cols()) ;
-  for(int i=0;i<rows();++i)
-    for(int j=0;j<cols();++j)
-      elem(i,j) = a(i,j) ;
+  for(int i=0;i<Matrix<T>::rows();++i)
+    for(int j=0;j<Matrix<T>::cols();++j)
+      this->elem(i,j) = a(i,j) ;
   pivot_ = a.pivot_ ;
   return *this ;
 }
@@ -90,7 +90,7 @@
   //	lu = a;	 must do it by copying or LUFACT will be recursively called !
   for(i=0;i<n;++i)
     for(j=0;j<n;++j)
-      elem(i,j) = a(i,j) ;
+      this->elem(i,j) = a(i,j) ;
 
   errval = 0;
   nm1 = n - 1;
@@ -129,24 +129,24 @@
 	    }
 	  pivot_[k] = l;
 
-	  if ( elem(l,k) != 0.0 )
+	  if ( this->elem(l,k) != 0.0 )
 	    {			// nonsingular pivot found 
 	      if (l != k ){	// interchange needed 
 		for (i = k; i < n; i++)
 		  {
-		    t = elem(l,i) ;
-		    elem(l,i) = elem(k,i) ;
-		    elem(k,i) = t ; 
+		    t = this->elem(l,i) ;
+		    this->elem(l,i) = this->elem(k,i) ;
+		    this->elem(k,i) = t ; 
 		  }
 		sign = -sign ;
 	      }
-	      q =  elem(k,k);	/* scale row */
+	      q =  this->elem(k,k);	/* scale row */
 	      for (i = kp1; i < n; i++)
 		{
-		  t = - elem(i,k)/q;
-		  elem(i,k) = t;
+		  t = - this->elem(i,k)/q;
+		  this->elem(i,k) = t;
 		  for (j = kp1; j < n; j++)
-		    elem(i,j) += t * elem(k,j);
+		    this->elem(i,j) += t * this->elem(k,j);
 		}
 	    }
 	  else		/* pivot singular */
@@ -156,7 +156,7 @@
     }
   
   pivot_[nm1] = nm1;
-  if (elem(nm1,nm1) == 0.0)
+  if (this->elem(nm1,nm1) == 0.0)
     errval = nm1;  
   return *this;
 }
@@ -166,7 +166,7 @@
 template <class T>
 Matrix<T> LUMatrix::operator Matrix()	
 {
-  int i, j, r = rows(), c = cols();
+  int i, j, r =Matrix<T>::rows(), c =Matrix<T>::cols();
 
   Matrix mat( r, c );
 	
@@ -196,9 +196,9 @@
 */
 template <class T>
 T LUMatrix<T>::determinant(){
-  T det = elem(0,0) ;
-  for(int i=1;i<rows();++i)
-    det *= elem(i,i) ;
+  T det = this->elem(0,0) ;
+  for(int i=1;i<Matrix<T>::rows();++i)
+    det *= this->elem(i,i) ;
   return det * (T)sign ;
 }
 
@@ -209,7 +209,7 @@
 void LUMatrix<T>::backSub(const Matrix<T>& B, Matrix<T>& X){
   int i,ii,ip,j,k ;
   T sum ;
-  int n = rows() ;
+  int n =Matrix<T>::rows() ;
   // one column at a time
   //X.resize(n,B.cols()) ;
   X = B ;
@@ -221,7 +221,7 @@
       X(ip,j) = X(i,j) ;
       if(ii)
 	for(k=ii;k<i;++k)
-	  sum -= elem(i,k)*X(k,j);
+	  sum -= this->elem(i,k)*X(k,j);
       else
 	if(sum)
 	  ii=i ;
@@ -230,7 +230,7 @@
     for(i=n-1;i>0;--i){ // doing forward substitution
       sum=X(i,j) ;
       for(k=i+1;k<n;++k)
-	sum -= elem(i,k)*X(k,j) ;
+	sum -= this->elem(i,k)*X(k,j) ;
       X(i,j) = sum/elem(i,i) ;
     }
   }
@@ -253,18 +253,18 @@
   T ten;
   int i, j, k, l, kb, kp1, nm1, n, coln;
 
-  if ( rows() != cols() )
+  if (Matrix<T>::rows() !=Matrix<T>::cols() )
     {
 #ifdef USE_EXCEPTION
-    throw WrongSize2D(rows(),cols(),0,0) ;
+    throw WrongSize2D(Matrix<T>::rows(),Matrix<T>::cols(),0,0) ;
 #else
       Error error("invm");
-      error << "matrix inverse, not square: " << rows() << " by " << cols() << endl;
+      error << "matrix inverse, not square: " <<Matrix<T>::rows() << " by " <<Matrix<T>::cols() << endl;
       error.fatal();
 #endif
     }
 
-  n = coln = rows();
+  n = coln =Matrix<T>::rows();
 
 
   inv = *this ;
@@ -338,13 +338,13 @@
 template <class T>
 Matrix<T> LUMatrix<T>::inverse() 
 {
-  if ( rows() != cols() )
+  if (Matrix<T>::rows() !=Matrix<T>::cols() )
     {
 #ifdef USE_EXCEPTION
-      throw WrongSize2D(rows(),cols(),0,0) ;
+      throw WrongSize2D(Matrix<T>::rows(),Matrix<T>::cols(),0,0) ;
 #else
       Error error("invm");
-      error << "matrix inverse, not square: " << rows() << " by " << cols() << endl;
+      error << "matrix inverse, not square: " <<Matrix<T>::rows() << " by " <<Matrix<T>::cols() << endl;
       error.fatal();
 #endif
     }
@@ -823,7 +823,7 @@
     throw WrongSize2D(A.rows(),A.cols(),0,0) ;
 #else
     Error err("SVD") ;
-    err << "Matrix A should have at least as many rows() as it has columns";
+    err << "Matrix A should have at least as manyMatrix<T>::rows() as it has columns";
     err.warning() ;
 #endif
     return 0 ;
Only in /home/makerpm/nurbs++-3.0.11/numerical: matrixMat_.lo
Only in /home/makerpm/nurbs++-3.0.11/numerical: matrixMat_.o
Only in /home/makerpm/nurbs++-3.0.11/numerical: statistic_.lo
Only in /home/makerpm/nurbs++-3.0.11/numerical: statistic_.o
Only in /home/makerpm/nurbs++-3.0.11/nurbs: d_curve.lo
Only in /home/makerpm/nurbs++-3.0.11/nurbs: d_curve.o
Only in /home/makerpm/nurbs++-3.0.11/nurbs: .deps
Only in /home/makerpm/nurbs++-3.0.11/nurbs: d_hnurbsS.lo
Only in /home/makerpm/nurbs++-3.0.11/nurbs: d_hnurbsS.o
Only in /home/makerpm/nurbs++-3.0.11/nurbs: d_hnurbsS_sp.lo
Only in /home/makerpm/nurbs++-3.0.11/nurbs: d_hnurbsS_sp.o
Only in /home/makerpm/nurbs++-3.0.11/nurbs: d_nurbsArray.lo
Only in /home/makerpm/nurbs++-3.0.11/nurbs: d_nurbsArray.o
diff -ur ./nurbs/d_nurbs.cpp /home/makerpm/nurbs++-3.0.11/nurbs/d_nurbs.cpp
--- ./nurbs/d_nurbs.cpp	2002-05-14 06:11:57.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/nurbs/d_nurbs.cpp	2009-01-24 03:06:01.000000000 +1100
@@ -10,6 +10,7 @@
   return firstDn(u) ;
 }
 
+template<> 
 void NurbsCurve<double,2>::makeCircle(const Point_nD<double,2>& O, double r, double as, double ae){
   makeCircle(O,Point_nD<double,2>(1,0),Point_nD<double,2>(0,1),r,as,ae) ;
 }
Only in /home/makerpm/nurbs++-3.0.11/nurbs: d_nurbs.lo
Only in /home/makerpm/nurbs++-3.0.11/nurbs: d_nurbs.o
Only in /home/makerpm/nurbs++-3.0.11/nurbs: d_nurbsS.lo
Only in /home/makerpm/nurbs++-3.0.11/nurbs: d_nurbsS.o
Only in /home/makerpm/nurbs++-3.0.11/nurbs: d_nurbs_sp.lo
Only in /home/makerpm/nurbs++-3.0.11/nurbs: d_nurbs_sp.o
Only in /home/makerpm/nurbs++-3.0.11/nurbs: d_nurbsS_sp.lo
Only in /home/makerpm/nurbs++-3.0.11/nurbs: d_nurbsS_sp.o
diff -ur ./nurbs/d_nurbsSub.cpp /home/makerpm/nurbs++-3.0.11/nurbs/d_nurbsSub.cpp
--- ./nurbs/d_nurbsSub.cpp	2002-05-14 06:11:57.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/nurbs/d_nurbsSub.cpp	2009-01-24 03:06:01.000000000 +1100
@@ -14,8 +14,8 @@
   template class RenderMeshPoints<double> ;
 
   
-  double NurbSurface<double>::epsilon = 1e-6 ;
-  double SurfSample<double>::epsilon = 1e-6 ;
+  template<> double NurbSurface<double>::epsilon = 1e-6 ;
+ template<>  double SurfSample<double>::epsilon = 1e-6 ;
 
   template void DrawSubdivision( NurbSurface<double> *, double tolerance );
   template void DrawEvaluation( NurbSurface<double> * );
Only in /home/makerpm/nurbs++-3.0.11/nurbs: d_nurbsSub.lo
Only in /home/makerpm/nurbs++-3.0.11/nurbs: d_nurbsSub.o
diff -ur ./nurbs/d_surface.cpp /home/makerpm/nurbs++-3.0.11/nurbs/d_surface.cpp
--- ./nurbs/d_surface.cpp	2002-05-17 02:44:49.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/nurbs/d_surface.cpp	2009-01-24 03:06:01.000000000 +1100
@@ -25,8 +25,9 @@
   template class InterPoint<double,2> ;
   template class InterPoint<double,3> ;
   
-  template class BasicList<InterPoint<double,2> > ; 
-  template class BasicList<InterPoint<double,3> > ; 
+  //TODO: External patcher's comment: BasicList not in PLib namespace?
+  //template class BasicList<InterPoint<double,2> > ; 
+  //template class BasicList<InterPoint<double,3> > ; 
   
   template class ParaSurface<double,2> ;
   template class ParaSurface<double,3> ;
Only in /home/makerpm/nurbs++-3.0.11/nurbs: d_surface.lo
Only in /home/makerpm/nurbs++-3.0.11/nurbs: d_surface.o
Only in /home/makerpm/nurbs++-3.0.11/nurbs: d_tri_spline.lo
Only in /home/makerpm/nurbs++-3.0.11/nurbs: d_tri_spline.o
Only in /home/makerpm/nurbs++-3.0.11/nurbs: f_curve.lo
Only in /home/makerpm/nurbs++-3.0.11/nurbs: f_curve.o
Only in /home/makerpm/nurbs++-3.0.11/nurbs: f_hnurbsS.lo
Only in /home/makerpm/nurbs++-3.0.11/nurbs: f_hnurbsS.o
Only in /home/makerpm/nurbs++-3.0.11/nurbs: f_hnurbsS_sp.lo
Only in /home/makerpm/nurbs++-3.0.11/nurbs: f_hnurbsS_sp.o
Only in /home/makerpm/nurbs++-3.0.11/nurbs: f_nurbsArray.lo
Only in /home/makerpm/nurbs++-3.0.11/nurbs: f_nurbsArray.o
Only in /home/makerpm/nurbs++-3.0.11/nurbs: f_nurbs.lo
Only in /home/makerpm/nurbs++-3.0.11/nurbs: f_nurbs.o
Only in /home/makerpm/nurbs++-3.0.11/nurbs: f_nurbsS.lo
Only in /home/makerpm/nurbs++-3.0.11/nurbs: f_nurbsS.o
Only in /home/makerpm/nurbs++-3.0.11/nurbs: f_nurbs_sp.lo
Only in /home/makerpm/nurbs++-3.0.11/nurbs: f_nurbs_sp.o
Only in /home/makerpm/nurbs++-3.0.11/nurbs: f_nurbsS_sp.lo
Only in /home/makerpm/nurbs++-3.0.11/nurbs: f_nurbsS_sp.o
diff -ur ./nurbs/f_nurbsSub.cpp /home/makerpm/nurbs++-3.0.11/nurbs/f_nurbsSub.cpp
--- ./nurbs/f_nurbsSub.cpp	2002-05-14 06:11:57.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/nurbs/f_nurbsSub.cpp	2009-01-24 03:06:01.000000000 +1100
@@ -14,8 +14,8 @@
   template class RenderMeshPoints<float> ;
 
   
-  float NurbSurface<float>::epsilon = 1e-6 ;
-  float SurfSample<float>::epsilon = 1e-6 ;
+  template<> float NurbSurface<float>::epsilon = 1e-6 ;
+  template<> float SurfSample<float>::epsilon = 1e-6 ;
 
   template void DrawSubdivision( NurbSurface<float> *, float tolerance );
   template void DrawEvaluation( NurbSurface<float> * );
Only in /home/makerpm/nurbs++-3.0.11/nurbs: f_nurbsSub.lo
Only in /home/makerpm/nurbs++-3.0.11/nurbs: f_nurbsSub.o
diff -ur ./nurbs/f_surface.cpp /home/makerpm/nurbs++-3.0.11/nurbs/f_surface.cpp
--- ./nurbs/f_surface.cpp	2002-05-17 02:44:49.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/nurbs/f_surface.cpp	2009-01-24 03:06:01.000000000 +1100
@@ -24,9 +24,11 @@
   
   template class InterPoint<float,2> ;
   template class InterPoint<float,3> ;
-  
-  template class BasicList<InterPoint<float,2> > ; 
-  template class BasicList<InterPoint<float,3> > ; 
+ 
+
+//This breaks the "NO_IMPLICIT_TEMPLATES" thingy. Does BasicList not belong to PLib? 
+//  template class BasicList<InterPoint<float,2> > ; 
+//  template class BasicList<InterPoint<float,3> > ; 
   
   template class ParaSurface<float,2> ;
   template class ParaSurface<float,3> ;
Only in /home/makerpm/nurbs++-3.0.11/nurbs: f_surface.lo
Only in /home/makerpm/nurbs++-3.0.11/nurbs: f_surface.o
Only in /home/makerpm/nurbs++-3.0.11/nurbs: f_tri_spline.lo
Only in /home/makerpm/nurbs++-3.0.11/nurbs: f_tri_spline.o
diff -ur ./nurbs/hnurbsS.cpp /home/makerpm/nurbs++-3.0.11/nurbs/hnurbsS.cpp
--- ./nurbs/hnurbsS.cpp	2002-05-18 04:24:21.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/nurbs/hnurbsS.cpp	2009-01-24 03:06:01.000000000 +1100
@@ -103,11 +103,11 @@
   initBase() ;
   offset.resize(baseSurf.ctrlPnts()) ;
 
-  P = baseSurf.ctrlPnts() ;
-  U = baseSurf.knotU() ;
-  V = baseSurf.knotV() ;
-  degU = baseSurf.degreeU() ;
-  degV = baseSurf.degreeV() ;
+  this->P = baseSurf.ctrlPnts() ;
+  this->U = baseSurf.knotU() ;
+  this->V = baseSurf.knotV() ;
+  this->degU = baseSurf.degreeU() ;
+  this->degV = baseSurf.degreeV() ;
 
   //updateSurface() ;
 
@@ -162,11 +162,11 @@
   baseUpdateN = baseLevel_->modifiedN()-1 ; // Set it so that initBase will run
   initBase() ;
   offset.resize(baseSurf.ctrlPnts()) ;
-  P = baseSurf.ctrlPnts() ;
-  U = baseSurf.knotU() ;
-  V = baseSurf.knotV() ;
-  degU = baseSurf.degreeU() ;
-  degV = baseSurf.degreeV() ;
+  this->P = baseSurf.ctrlPnts() ;
+  this->U = baseSurf.knotU() ;
+  this->V = baseSurf.knotV() ;
+  this->degU = baseSurf.degreeU() ;
+  this->degV = baseSurf.degreeV() ;
   //updateSurface() ;
 
 }
@@ -200,7 +200,7 @@
   rU.resize(0) ;
   rV.resize(0) ;
 
-  offset = P ;
+  offset = this->P ;
 }
 
 /*!
@@ -334,11 +334,11 @@
   }
   if(baseLevel_){
     if(initBase()){
-      P = baseSurf.ctrlPnts() ;
-      U = baseSurf.knotU() ;
-      V = baseSurf.knotV() ;
-      degU = baseSurf.degreeU() ;
-      degV = baseSurf.degreeV() ;
+      this->P = baseSurf.ctrlPnts() ;
+      this->U = baseSurf.knotU() ;
+      this->V = baseSurf.knotV() ;
+      this->degU = baseSurf.degreeU() ;
+      this->degV = baseSurf.degreeV() ;
     }
     if(i0>=0 && j0>=0){
       Point_nD<T,N> vecOffset ;
@@ -352,13 +352,13 @@
 	  offset(i0,j0).y()*jvec(i0,j0) +
 	  offset(i0,j0).z()*kvec(i0,j0) ;
       }
-      P(i0,j0).x() = baseSurf.ctrlPnts()(i0,j0).x()+vecOffset.x() ;
-      P(i0,j0).y() = baseSurf.ctrlPnts()(i0,j0).y()+vecOffset.y() ;
-      P(i0,j0).z() = baseSurf.ctrlPnts()(i0,j0).z()+vecOffset.z() ;
+      this->P(i0,j0).x() = baseSurf.ctrlPnts()(i0,j0).x()+vecOffset.x() ;
+      this->P(i0,j0).y() = baseSurf.ctrlPnts()(i0,j0).y()+vecOffset.y() ;
+      this->P(i0,j0).z() = baseSurf.ctrlPnts()(i0,j0).z()+vecOffset.z() ;
     }
     else{
-      for(int i=0;i<P.rows();++i)
-	for(int j=0;j<P.cols();++j){
+      for(int i=0;i<this->P.rows();++i)
+	for(int j=0;j<this->P.cols();++j){
 	  if(offset(i,j).x() != 0 || 
 	     offset(i,j).y() != 0 || offset(i,j).z() || 0){
 	    Point_nD<T,N> vecOffset ;
@@ -372,20 +372,20 @@
 		offset(i,j).y()*jvec(i,j) +
 		offset(i,j).z()*kvec(i,j) ;
 	    }
-	    P(i,j).x() = baseSurf.ctrlPnts()(i,j).x()+vecOffset.x() ;
-	    P(i,j).y() = baseSurf.ctrlPnts()(i,j).y()+vecOffset.y() ;
-	    P(i,j).z() = baseSurf.ctrlPnts()(i,j).z()+vecOffset.z() ;
+	    this->P(i,j).x() = baseSurf.ctrlPnts()(i,j).x()+vecOffset.x() ;
+	    this->P(i,j).y() = baseSurf.ctrlPnts()(i,j).y()+vecOffset.y() ;
+	    this->P(i,j).z() = baseSurf.ctrlPnts()(i,j).z()+vecOffset.z() ;
 	  }
 	}
     }
   }
   else{
     if(i0>=0 && j0>=0)
-      P(i0,j0) = offset(i0,j0) ;
+      this->P(i0,j0) = offset(i0,j0) ;
     else{
-      for(int i=0;i<P.rows();++i)
-	for(int j=0;j<P.cols();++j){
-	  P(i,j) = offset(i,j) ;
+      for(int i=0;i<this->P.rows();++i)
+	for(int j=0;j<this->P.cols();++j){
+	  this->P(i,j) = offset(i,j) ;
 	}
     }
   }
@@ -554,17 +554,17 @@
       return mod ;
   }
 
-  if(u<knotU()[0] || u>knotU()[knotU().n()-1])
+  if(u<(this->knotU())[0] || u>(this->knotU())[(this->knotU()).n()-1])
     return -1 ;
-  if(v<knotV()[0] || v>knotU()[knotV().n()-1])
+  if(v<(this->knotV())[0] || v>(this->knotU())[(this->knotV()).n()-1])
     return -1 ;
 
   int su = findSpanU(u) ;
   int sv = findSpanV(v) ;
 
-  for(int i=0;i<=degU;++i)
-    for(int j=0;j<=degV;++j){
-      if(offset(su-degU+i,sv+degV+j) != HPoint_nD<T,N>(0,0,0,0))
+  for(int i=0;i<=this->degU;++i)
+    for(int j=0;j<=this->degV;++j){
+      if(offset(su-this->degU+i,sv+this->degV+j) != HPoint_nD<T,N>(0,0,0,0))
 	return level_ ;
     }
 
@@ -742,16 +742,16 @@
 template <class T, int N>
 void HNurbsSurface<T,N>::splitUV(int nu, int nv, Vector<T> &nU, Vector<T> &nV){
 
-  nU.resize(knotU().n()*nu) ;
-  nV.resize(knotV().n()*nv) ;
+  nU.resize((this->knotU()).n()*nu) ;
+  nV.resize((this->knotV()).n()*nv) ;
   
   int i,j,n ;
 
   n = 0 ; 
-  for(i=1;i<knotU().n();++i){
-    if(knotU()[i] >knotU()[i-1]){
-      T a = knotU()[i-1] ;
-      T b = knotU()[i] ;
+  for(i=1;i<(this->knotU()).n();++i){
+    if((this->knotU())[i] >(this->knotU())[i-1]){
+      T a = (this->knotU())[i-1] ;
+      T b = (this->knotU())[i] ;
 
 
       for(j=0;j<nu;++j){
@@ -763,10 +763,10 @@
   nU.resize(n) ;
 
   n = 0 ;
-  for(i=1;i<knotV().n();++i){
-    if(knotV()[i] > knotV()[i-1]){
-      T a = knotV()[i-1] ;
-      T b = knotV()[i] ;
+  for(i=1;i<(this->knotV()).n();++i){
+    if((this->knotV())[i] > (this->knotV())[i-1]){
+      T a = (this->knotV())[i-1] ;
+      T b = (this->knotV())[i] ;
 
       for(j=0;j<nv;++j){
 	nV[n] = a + (b-a)*T(j+1)/T(nv+1) ;
@@ -805,22 +805,22 @@
   int i,j,n ;
 
   if(su<=0)
-    su = degU  ;
+    su = this->degU  ;
   if(sv<=0)
-    sv = degV  ;
-  if(su>degU+1)
-    su = degU+1 ;
-  if(sv>degV+1)
-    sv = degV+1 ;
+    sv = this->degV  ;
+  if(su>this->degU+1)
+    su = this->degU+1 ;
+  if(sv>this->degV+1)
+    sv = this->degV+1 ;
 
-  nU.resize(knotU().n()*nu*su) ;
-  nV.resize(knotV().n()*nv*sv) ;
+  nU.resize((this->knotU()).n()*nu*su) ;
+  nV.resize((this->knotV()).n()*nv*sv) ;
   
   n = 0 ; 
-  for(i=1;i<knotU().n();++i){
-    if(knotU()[i] >knotU()[i-1]){
-      T a = knotU()[i-1] ;
-      T b = knotU()[i] ;
+  for(i=1;i<(this->knotU()).n();++i){
+    if((this->knotU())[i] >(this->knotU())[i-1]){
+      T a = (this->knotU())[i-1] ;
+      T b = (this->knotU())[i] ;
 
 
       for(j=0;j<nu;++j){
@@ -835,10 +835,10 @@
   nU.resize(n) ;
 
   n = 0 ;
-  for(i=1;i<knotV().n();++i){
-    if(knotV()[i] > knotV()[i-1]){
-      T a = knotV()[i-1] ;
-      T b = knotV()[i] ;
+  for(i=1;i<(this->knotV()).n();++i){
+    if((this->knotV())[i] > (this->knotV())[i-1]){
+      T a = (this->knotV())[i-1] ;
+      T b = (this->knotV())[i] ;
 
       for(j=0;j<nv;++j){
 	T v = a + (b-a)*T(j+1)/T(nv+1) ;
@@ -1014,10 +1014,10 @@
     if(!fin.read((char*)&du,sizeof(int))) { delete []type ; return 0 ;}
     if(!fin.read((char*)&dv,sizeof(int))) { delete []type ; return 0 ;}
     
-    resize(nu,nv,du,dv) ;
+    this->resize(nu,nv,du,dv) ;
     
-    if(!fin.read((char*)U.memory(),sizeof(T)*U.n())) { delete []type ; return 0 ;}
-    if(!fin.read((char*)V.memory(),sizeof(T)*V.n())) { delete []type ; return 0 ;}
+    if(!fin.read((char*)(this->U).memory(),sizeof(T)*(this->U).n())) { delete []type ; return 0 ;}
+    if(!fin.read((char*)(this->V).memory(),sizeof(T)*(this->V).n())) { delete []type ; return 0 ;}
     
     if(!r1){
       p = new T[3*nu*nv] ;
@@ -1025,10 +1025,10 @@
       p2 = p ;
       for(int i=0;i<nu;i++)
 	for(int j=0;j<nv;j++){
-	  P(i,j).x() = *(p++) ;
-	  P(i,j).y() = *(p++) ;
-	  P(i,j).z() = *(p++) ;
-	  P(i,j).w() = 1.0 ;
+	  this->P(i,j).x() = *(p++) ;
+	  this->P(i,j).y() = *(p++) ;
+	  this->P(i,j).z() = *(p++) ;
+	  this->P(i,j).w() = 1.0 ;
 	}
       delete []p2 ;
     }
@@ -1038,14 +1038,14 @@
       p2 = p ;
       for(int i=0;i<nu;i++)
 	for(int j=0;j<nv;j++){
-	  P(i,j).x() = *(p++) ;
-	  P(i,j).y() = *(p++) ;
-	  P(i,j).z() = *(p++) ;
-	  P(i,j).w() = *(p++) ;
+	  this->P(i,j).x() = *(p++) ;
+	  this->P(i,j).y() = *(p++) ;
+	  this->P(i,j).z() = *(p++) ;
+	  this->P(i,j).w() = *(p++) ;
 	}
       delete []p2 ;
     }
-    offset = P ;
+    offset = this->P ;
     this->updateSurface() ;
   }
   else { // reading the offset information
@@ -1144,29 +1144,29 @@
   if(!fout)
     return 0 ;
   if(!baseLevel_){
-    int prows = P.rows();
-    int pcols = P.cols();
+    int prows = this->P.rows();
+    int pcols = this->P.cols();
     char st = '0' + sizeof(T) ; 
     if(!fout.write((char*)&"hns4",sizeof(char)*4)) return 0 ;
     if(!fout.write((char*)&st,sizeof(char))) return 0 ; 
     if(!fout.write((char*)&prows,sizeof(int))) return 0 ;
     if(!fout.write((char*)&pcols,sizeof(int))) return 0 ;
-    if(!fout.write((char*)&degU,sizeof(int))) return 0 ;
-    if(!fout.write((char*)&degV,sizeof(int))) return 0 ;
-    if(!fout.write((char*)U.memory(),sizeof(T)*U.n())) return 0 ;
-    if(!fout.write((char*)V.memory(),sizeof(T)*V.n())) return 0 ;
+    if(!fout.write((char*)&this->degU,sizeof(int))) return 0 ;
+    if(!fout.write((char*)&this->degV,sizeof(int))) return 0 ;
+    if(!fout.write((char*)this->U.memory(),sizeof(T)*this->U.n())) return 0 ;
+    if(!fout.write((char*)this->V.memory(),sizeof(T)*this->V.n())) return 0 ;
     
     T *p,*p2 ;
-    p = new T[P.rows()*P.cols()*4] ;
+    p = new T[this->P.rows()*this->P.cols()*4] ;
     p2 = p ;
-    for(int i=0;i<P.rows();i++) 
-      for(int j=0;j<P.cols();j++){
+    for(int i=0;i<this->P.rows();i++) 
+      for(int j=0;j<this->P.cols();j++){
 	*p = offset(i,j).x() ; p++ ;
 	*p = offset(i,j).y() ; p++ ;
 	*p = offset(i,j).z() ; p++ ;
 	*p = offset(i,j).w() ; p++ ;
       }
-    if(!fout.write((char*)p2,sizeof(T)*P.rows()*P.cols()*4)) return 0 ;
+    if(!fout.write((char*)p2,sizeof(T)*this->P.rows()*this->P.cols()*4)) return 0 ;
     delete []p2 ;
   }
   else{
@@ -1282,7 +1282,7 @@
   int i,j ;
   j = 0 ;
   for(i=0;i<X.n();++i){
-    if(X[i]>=U[0] && X[i]<=U[U.n()-1]){
+    if(X[i]>=this->U[0] && X[i]<=this->U[this->U.n()-1]){
       Xu[j] = X[i] ;
       ++j ;
     }
@@ -1294,7 +1294,7 @@
       nextLevel_->refineKnotU(Xu) ;
     }
     
-    NurbsSurface<T,N> osurf(degU,degV,U,V,offset) ;
+    NurbsSurface<T,N> osurf(this->degU,this->degV,this->U,this->V,offset) ;
     
     osurf.refineKnotU(Xu) ;
     
@@ -1324,7 +1324,7 @@
   int i,j ;
   j = 0 ;
   for(i=0;i<X.n();++i){
-    if(X[i]>=V[0] && X[i]<=V[V.n()-1]){
+    if(X[i]>=this->V[0] && X[i]<=this->V[this->V.n()-1]){
       Xv[j] = X[i] ;
       ++j ;
     }
@@ -1336,7 +1336,7 @@
       nextLevel_->refineKnotV(Xv) ;
     }
     
-    NurbsSurface<T,N> osurf(degU,degV,U,V,offset) ;
+    NurbsSurface<T,N> osurf(this->degU,this->degV,this->U,this->V,offset) ;
     
     osurf.refineKnotV(Xv) ;
     
@@ -1370,26 +1370,26 @@
 */
 template <class T, int N>
 int HNurbsSurface<T,N>::movePointOffset(T u, T v, const Point_nD<T,N>& delta){
-  P = offset ; 
+  this->P = offset ; 
 
   // by definition the offset has w = 0 , but this isn't valid for
   // the control points, increasing the w by 1, will generate a valid surface
   if(baseLevel_)
-    for(int i=0;i<P.rows();++i)
-      for(int j=0;j<P.cols();++j){
-	P(i,j).w() += T(1) ; 
+    for(int i=0;i<this->P.rows();++i)
+      for(int j=0;j<this->P.cols();++j){
+	this->P(i,j).w() += T(1) ; 
       }
 
   if(NurbsSurface<T,N>::movePoint(u,v,delta)){
-    offset = P ;
+    offset = this->P ;
     // need to reset the offset weights
     if(baseLevel_)
-      for(int i=0;i<P.rows();++i)
-	for(int j=0;j<P.cols();++j){
-	  P(i,j).w() -= T(1) ; 
+      for(int i=0;i<this->P.rows();++i)
+	for(int j=0;j<this->P.cols();++j){
+	  this->P(i,j).w() -= T(1) ; 
       }
     
-    P = baseSurf.ctrlPnts() ; 
+    this->P = baseSurf.ctrlPnts() ; 
     updateSurface() ; 
     return 1 ;
   }
diff -ur ./nurbs/hnurbsS_sp.cpp /home/makerpm/nurbs++-3.0.11/nurbs/hnurbsS_sp.cpp
--- ./nurbs/hnurbsS_sp.cpp	2002-05-14 07:07:46.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/nurbs/hnurbsS_sp.cpp	2009-01-24 03:06:01.000000000 +1100
@@ -43,7 +43,7 @@
 */
 template <class T, int N>
 void HNurbsSurfaceSP<T,N>::updateMaxU() {
-  if(degU>3){
+  if(this->degU>3){
 #ifdef USE_EXCEPTION
     throw NurbsError();
 #else
@@ -53,12 +53,12 @@
 #endif
   }
   else{
-    maxU.resize(P.rows()) ;
-    maxAtU_.resize(P.rows()) ;
-    for(int i=0;i<P.rows();++i){
-      if(!maxInfluence(i,U,degU,maxAtU_[i]))
+    maxU.resize(this->P.rows()) ;
+    maxAtU_.resize(this->P.rows()) ;
+    for(int i=0;i<this->P.rows();++i){
+      if(!maxInfluence(i,this->U,this->degU,maxAtU_[i]))
 	cerr << "Problem in maxInfluence U!\n" ;
-      maxU[i] = nurbsBasisFun(maxAtU_[i],i,degU,U) ;
+      maxU[i] = nurbsBasisFun(maxAtU_[i],i,this->degU,this->U) ;
     }
     
   }
@@ -78,7 +78,7 @@
 */
 template <class T, int N>
 void HNurbsSurfaceSP<T,N>::updateMaxV() {
-  if(degV>3){
+  if(this->degV>3){
 #ifdef USE_EXCEPTION
     throw NurbsError();
 #else
@@ -88,12 +88,12 @@
 #endif
   }
   else{
-    maxV.resize(P.cols()) ;
-    maxAtV_.resize(P.cols()) ;
-    for(int i=0;i<P.cols();++i){
-      if(!maxInfluence(i,V,degV,maxAtV_[i]))
+    maxV.resize(this->P.cols()) ;
+    maxAtV_.resize(this->P.cols()) ;
+    for(int i=0;i<this->P.cols();++i){
+      if(!maxInfluence(i,this->V,this->degV,maxAtV_[i]))
 	cerr << "Problem in maxInfluence V!\n" ;
-      maxV[i] = nurbsBasisFun(maxAtV_[i],i,degV,V) ;
+      maxV[i] = nurbsBasisFun(maxAtV_[i],i,this->degV,this->V) ;
     }
     
   }
@@ -111,20 +111,21 @@
   \author Philippe Lavoie
   \date 14 May, 1998
 */
+template<>
 template <class T, int N>
 void HNurbsSurfaceSP<T,N>::modSurfCPby(int i, int j, const HPoint_nD<T,N>& a) {
-  offset(i,j) +=  a / (maxU[i]*maxV[j]) ; 
-  if(baseLevel_){
+  this->offset(i,j) +=  a / (maxU[i]*maxV[j]) ; 
+  if(this->baseLevel_){
     Point_nD<T,N> vecOffset ; 
-    vecOffset = offset(i,j).x()*ivec(i,j) +
-      offset(i,j).y()*jvec(i,j) +
-      offset(i,j).z()*kvec(i,j) ;
-    P(i,j).x() = baseSurf.ctrlPnts()(i,j).x()+vecOffset.x() ;
-    P(i,j).y() = baseSurf.ctrlPnts()(i,j).y()+vecOffset.y() ;
-    P(i,j).z() = baseSurf.ctrlPnts()(i,j).z()+vecOffset.z() ;
+    vecOffset = this->offset(i,j).x()*this->ivec(i,j) +
+      this->offset(i,j).y()*this->jvec(i,j) +
+      this->offset(i,j).z()*this->kvec(i,j) ;
+    this->P(i,j).x() = this->baseSurf.ctrlPnts()(i,j).x()+vecOffset.x() ;
+    this->P(i,j).y() = this->baseSurf.ctrlPnts()(i,j).y()+vecOffset.y() ;
+    this->P(i,j).z() = this->baseSurf.ctrlPnts()(i,j).z()+vecOffset.z() ;
   }
   else
-    P(i,j) = offset(i,j) ; 
+    this->P(i,j) = this->offset(i,j) ; 
 }
 
 /*!
@@ -151,24 +152,24 @@
 void HNurbsSurfaceSP<T,N>::modOnlySurfCPby(int i, int j, const HPoint_nD<T,N>& a){
   int k ; 
 
-  P = offset ; 
+  this->P = this->offset ; 
 
   // by definition the offset has w = 0 , but this isn't valid for
   // the control points, increasing the w by 1, will generate a valid surface
-  if(baseLevel_)
-    for(k=0;k<P.rows();++k)
-      for(int l=0;l<P.cols();++l)
-	P(k,l).w() += T(1) ; 
+  if(this->baseLevel_)
+    for(k=0;k<this->P.rows();++k)
+      for(int l=0;l<this->P.cols();++l)
+	this->P(k,l).w() += T(1) ; 
 
   int sizeU, sizeV ;
 
-  sizeU = 2*degU+3 ; 
-  if(i-degU-1<0) sizeU += i-degU-1 ; 
-  if(i+degU+1>=P.rows()) sizeU -= i+degU+1-P.rows() ;
-
-  sizeV = 2*degV+3 ;
-  if(j-degV-1<0) sizeV += j-degV-1 ; 
-  if(j+degV+1>=P.cols()) sizeV -= j+degV+1-P.cols() ;
+  sizeU = 2*this->degU+3 ; 
+  if(i-this->degU-1<0) sizeU += i-this->degU-1 ; 
+  if(i+this->degU+1>=this->P.rows()) sizeU -= i+this->degU+1-this->P.rows() ;
+
+  sizeV = 2*this->degV+3 ;
+  if(j-this->degV-1<0) sizeV += j-this->degV-1 ; 
+  if(j+this->degV+1>=this->P.cols()) sizeV -= j+this->degV+1-this->P.cols() ;
   
   Vector<T> u(sizeU) ;
   Vector<T> v(sizeV) ;
@@ -179,16 +180,16 @@
   int n=0;
   int nu = 0 ;
   int nv = 0 ; 
-  for(k=i-degU-1;k<=i+degU+1;++k){
+  for(k=i-this->degU-1;k<=i+this->degU+1;++k){
     if(k<0)
       continue ;
-    if(k>=P.rows())
+    if(k>=this->P.rows())
       break ; 
     nv = 0 ;
-    for(int l=j-degV-1;l<=j+degV+1;++l){
+    for(int l=j-this->degV-1;l<=j+this->degV+1;++l){
       if(l<0)
 	continue ;
-      if(l>=P.cols())
+      if(l>=this->P.cols())
 	break ; 
       if( k == i && j==l){
 	pts[n].x() = a.x() ; 
@@ -216,12 +217,12 @@
   pv.resize(n) ; 
 
   if(NurbsSurface<T,N>::movePoint(u,v,pts,pu,pv)){
-    offset = P ; 
+    this->offset = this->P ; 
     // an offset shouldn't have a weight value.
-    if(baseLevel_)
-      for(k=0;k<P.rows();++k)
-	for(int l=0;l<P.cols();++l)
-	  offset(k,l).w() -= T(1) ; 
+    if(this->baseLevel_)
+      for(k=0;k<this->P.rows();++k)
+	for(int l=0;l<this->P.cols();++l)
+	  this->offset(k,l).w() -= T(1) ; 
   }
   updateSurface(); 
 }
@@ -262,7 +263,7 @@
 HNurbsSurfaceSP<T,N>* HNurbsSurfaceSP<T,N>::addLevel(int n, int s) {
   HNurbsSurfaceSP<T,N> *newLevel ;
 
-  if(nextLevel_)
+  if(this->nextLevel_)
     return 0 ;
 
   Vector<T> newU,newV ;
@@ -289,7 +290,7 @@
 HNurbsSurfaceSP<T,N>* HNurbsSurfaceSP<T,N>::addLevel() {
   HNurbsSurfaceSP<T,N> *newLevel ;
 
-  if(nextLevel_)
+  if(this->nextLevel_)
     return 0 ;
 
   newLevel = new HNurbsSurfaceSP<T,N>(this) ;
@@ -311,23 +312,23 @@
   levelP = nS.nextLevel() ;
 
   NurbsSurface<T,N>::operator=(nS) ;
-  rU = nS.rU ;
-  rV = nS.rV ;
-  offset = nS.offset ;
+  this->rU = nS.rU ;
+  this->rV = nS.rV ;
+  this->offset = nS.offset ;
 
   updateMaxUV() ; 
 
-  firstLevel_ = this ;
+  this->firstLevel_ = this ;
 
   if(levelP){
     HNurbsSurfaceSP<T,N> *newLevel ;
     newLevel =  new HNurbsSurfaceSP<T,N>(this) ; 
     newLevel->copy(*levelP) ;
-    nextLevel_ = newLevel ;
-    lastLevel_ = nextLevel_->lastLevel() ;
+    this->nextLevel_ = newLevel ;
+    this->lastLevel_ = this->nextLevel_->lastLevel() ;
   }
   else{
-    lastLevel_ = this ;
+    this->lastLevel_ = this ;
   }
 
 }
@@ -349,55 +350,55 @@
 template <class T, int N>
 void HNurbsSurfaceSP<T,N>::updateSurface(int i0, int j0){
   if(i0>=0 && j0>=0){
-    if(offset(i0,j0).x()==0.0 && offset(i0,j0).y()==0.0 && offset(i0,j0).z()==0.0)
+    if(this->offset(i0,j0).x()==0.0 && this->offset(i0,j0).y()==0.0 && this->offset(i0,j0).z()==0.0)
       return ;
   }
-  if(baseLevel_){
-    if(initBase()){
-      P = baseSurf.ctrlPnts() ;
-      U = baseSurf.knotU() ;
-      V = baseSurf.knotV() ;
-      degU = baseSurf.degreeU() ;
-      degV = baseSurf.degreeV() ;
+  if(this->baseLevel_){
+    if(this->initBase()){
+      this->P = this->baseSurf.ctrlPnts() ;
+      this->U = this->baseSurf.knotU() ;
+      this->V = this->baseSurf.knotV() ;
+      this->degU = this->baseSurf.degreeU() ;
+      this->degV = this->baseSurf.degreeV() ;
       updateMaxUV() ; 
     }
     if(i0>=0 && j0>=0){
       Point_nD<T,N> vecOffset ;
-      vecOffset = offset(i0,j0).x()*ivec(i0,j0) +
-	offset(i0,j0).y()*jvec(i0,j0) +
-	offset(i0,j0).z()*kvec(i0,j0) ;
-      P(i0,j0).x() = baseSurf.ctrlPnts()(i0,j0).x()+vecOffset.x() ;
-      P(i0,j0).y() = baseSurf.ctrlPnts()(i0,j0).y()+vecOffset.y() ;
-      P(i0,j0).z() = baseSurf.ctrlPnts()(i0,j0).z()+vecOffset.z() ;
+      vecOffset = this->offset(i0,j0).x()*this->ivec(i0,j0) +
+	this->offset(i0,j0).y()*this->jvec(i0,j0) +
+	this->offset(i0,j0).z()*this->kvec(i0,j0) ;
+      this->P(i0,j0).x() = this->baseSurf.ctrlPnts()(i0,j0).x()+vecOffset.x() ;
+      this->P(i0,j0).y() = this->baseSurf.ctrlPnts()(i0,j0).y()+vecOffset.y() ;
+      this->P(i0,j0).z() = this->baseSurf.ctrlPnts()(i0,j0).z()+vecOffset.z() ;
     }
     else{
-      for(int i=0;i<P.rows();++i)
-	for(int j=0;j<P.cols();++j){
-	  if(offset(i,j).x() != 0 || 
-	     offset(i,j).y() != 0 || offset(i,j).z() || 0){
+      for(int i=0;i<this->P.rows();++i)
+	for(int j=0;j<this->P.cols();++j){
+	  if(this->offset(i,j).x() != 0 || 
+	     this->offset(i,j).y() != 0 || this->offset(i,j).z() || 0){
 	    Point_nD<T,N> vecOffset ;
-	    vecOffset = offset(i,j).x()*ivec(i,j) +
-	      offset(i,j).y()*jvec(i,j) +
-	      offset(i,j).z()*kvec(i,j) ;
-	    P(i,j).x() = baseSurf.ctrlPnts()(i,j).x()+vecOffset.x() ;
-	    P(i,j).y() = baseSurf.ctrlPnts()(i,j).y()+vecOffset.y() ;
-	    P(i,j).z() = baseSurf.ctrlPnts()(i,j).z()+vecOffset.z() ;
+	    vecOffset = this->offset(i,j).x()*this->ivec(i,j) +
+	      this->offset(i,j).y()*this->jvec(i,j) +
+	      this->offset(i,j).z()*this->kvec(i,j) ;
+	    this->P(i,j).x() = this->baseSurf.ctrlPnts()(i,j).x()+vecOffset.x() ;
+	    this->P(i,j).y() = this->baseSurf.ctrlPnts()(i,j).y()+vecOffset.y() ;
+	    this->P(i,j).z() = this->baseSurf.ctrlPnts()(i,j).z()+vecOffset.z() ;
 	  }
 	}
     }
   }
   else{
     if(i0>=0 && j0>=0)
-      P(i0,j0) = offset(i0,j0) ;
+      this->P(i0,j0) = this->offset(i0,j0) ;
     else{
-      for(int i=0;i<P.rows();++i)
-	for(int j=0;j<P.cols();++j){
-	  P(i,j) = offset(i,j) ;
+      for(int i=0;i<this->P.rows();++i)
+	for(int j=0;j<this->P.cols();++j){
+	  this->P(i,j) = this->offset(i,j) ;
 	}
     }
   }
 
-  ++updateN ;
+  this->updateN++ ;
 }
 
 /*!
@@ -413,7 +414,7 @@
   if(!okMax())
     updateMaxUV() ; 
   if(upLevel>=0){
-    if(level()<=upLevel){
+    if(this->level()<=upLevel){
       this->updateSurface() ;
     }
   }
@@ -421,9 +422,9 @@
     this->updateSurface() ;
   }
 
-  if(upLevel>level() || upLevel<0){
-    if(nextLevel_)
-      ((HNurbsSurfaceSP<T,N>*)nextLevel_)->updateLevels(upLevel) ;
+  if(upLevel>this->level() || upLevel<0){
+    if(this->nextLevel_)
+      ((HNurbsSurfaceSP<T,N>*)this->nextLevel_)->updateLevels(upLevel) ;
   }
 }
 
@@ -458,10 +459,10 @@
     if(!fin.read((char*)&du,sizeof(int))) { delete []type ; return 0 ;}
     if(!fin.read((char*)&dv,sizeof(int))) { delete []type ; return 0 ;}
     
-    resize(nu,nv,du,dv) ;
+    this->resize(nu,nv,du,dv) ;
     
-    if(!fin.read((char*)U.memory(),sizeof(T)*U.n())) { delete []type ; return 0 ;}
-    if(!fin.read((char*)V.memory(),sizeof(T)*V.n())) { delete []type ; return 0 ;}
+    if(!fin.read((char*)this->U.memory(),sizeof(T)*this->U.n())) { delete []type ; return 0 ;}
+    if(!fin.read((char*)this->V.memory(),sizeof(T)*this->V.n())) { delete []type ; return 0 ;}
     
     if(!r1){
       p = new T[3*nu*nv] ;
@@ -469,10 +470,10 @@
       p2 = p ;
       for(int i=0;i<nu;i++)
 	for(int j=0;j<nv;j++){
-	  P(i,j).x() = *(p++) ;
-	  P(i,j).y() = *(p++) ;
-	  P(i,j).z() = *(p++) ;
-	  P(i,j).w() = 1.0 ;
+	  this->P(i,j).x() = *(p++) ;
+	  this->P(i,j).y() = *(p++) ;
+	  this->P(i,j).z() = *(p++) ;
+	  this->P(i,j).w() = 1.0 ;
 	}
       delete []p2 ;
     }
@@ -482,26 +483,26 @@
       p2 = p ;
       for(int i=0;i<nu;i++)
 	for(int j=0;j<nv;j++){
-	  P(i,j).x() = *(p++) ;
-	  P(i,j).y() = *(p++) ;
-	  P(i,j).z() = *(p++) ;
-	  P(i,j).w() = *(p++) ;
+	  this->P(i,j).x() = *(p++) ;
+	  this->P(i,j).y() = *(p++) ;
+	  this->P(i,j).z() = *(p++) ;
+	  this->P(i,j).w() = *(p++) ;
 	}
       delete []p2 ;
     }
-    offset = P ;
+    this->offset = this->P ;
     this->updateSurface() ;
   }
   else { // reading the offset information
     int ru,rv ;
     if(!fin.read((char*)&ru,sizeof(int))) { delete []type ; return 0 ;}
     if(!fin.read((char*)&rv,sizeof(int))) { delete []type ; return 0 ;}
-    rU.resize(ru) ;
-    rV.resize(rv) ;
-    if(rU.n()>0)
-      if(!fin.read((char*)rU.memory(),sizeof(T)*rU.n())) { delete []type ; return 0 ;}
-    if(rV.n()>0)
-      if(!fin.read((char*)rV.memory(),sizeof(T)*rV.n())) { delete []type ; return 0 ;}
+    this->rU.resize(ru) ;
+    this->rV.resize(rv) ;
+    if(this->rU.n()>0)
+      if(!fin.read((char*)this->rU.memory(),sizeof(T)*this->rU.n())) { delete []type ; return 0 ;}
+    if(this->rV.n()>0)
+      if(!fin.read((char*)this->rV.memory(),sizeof(T)*this->rV.n())) { delete []type ; return 0 ;}
     
     if(!fin.read((char*)&nu,sizeof(int))) { delete []type ; return 0 ;}
     if(!fin.read((char*)&nv,sizeof(int))) { delete []type ; return 0 ;}
@@ -509,16 +510,16 @@
     p = new T[4*nu*nv] ;
     if(!fin.read((char*)p,sizeof(T)*4*nu*nv)) { delete []type ; return 0 ;}
     p2 = p ;
-    offset.resize(nu,nv) ;
+    this->offset.resize(nu,nv) ;
     for(int i=0;i<nu;i++)
       for(int j=0;j<nv;j++){
-	offset(i,j).x() = *(p++) ;
-	offset(i,j).y() = *(p++) ;
-	offset(i,j).z() = *(p++) ;
-	offset(i,j).w() = *(p++) ;
+	this->offset(i,j).x() = *(p++) ;
+	this->offset(i,j).y() = *(p++) ;
+	this->offset(i,j).z() = *(p++) ;
+	this->offset(i,j).w() = *(p++) ;
       }
     delete []p2 ;    
-    --baseUpdateN ;
+    this->baseUpdateN-- ;
     this->updateSurface() ;
   }
 
Only in /home/makerpm/nurbs++-3.0.11/nurbs: libnurbsd.la
Only in /home/makerpm/nurbs++-3.0.11/nurbs: libnurbsf.la
Only in /home/makerpm/nurbs++-3.0.11/nurbs: .libs
Only in /home/makerpm/nurbs++-3.0.11/nurbs: Makefile
diff -ur ./nurbs/matrixRT.cpp /home/makerpm/nurbs++-3.0.11/nurbs/matrixRT.cpp
--- ./nurbs/matrixRT.cpp	2002-05-14 07:07:46.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/nurbs/matrixRT.cpp	2009-01-24 03:06:01.000000000 +1100
@@ -51,13 +51,13 @@
   // *this = C.translate(x,y,z)*B.rotate(ax,ay,az) ;
   rotate(ax,ay,az) ;
 #ifdef COLUMN_ORDER
-  m[12] = x ;
-  m[13] = y ;
-  m[14] = z ;  
+  this->m[12] = x ;
+  this->m[13] = y ;
+  this->m[14] = z ;  
 #else
-  m[3] = x ;
-  m[7] = y ;
-  m[11] = z ;
+  this->m[3] = x ;
+  this->m[7] = y ;
+  this->m[11] = z ;
 #endif
 }
 
@@ -71,8 +71,8 @@
  */
 template <class T>
 MatrixRT<T>::MatrixRT() : Matrix<T>(4,4) {
-  reset(0) ;
-  diag(1.0) ;
+  this->reset(0) ;
+  this->diag(1.0) ;
 }
 
 /*!
@@ -85,6 +85,7 @@
   \author Philippe Lavoie 
   \date 25 July, 1997
  */
+template<>
 template <class T>
 MatrixRT<T>::MatrixRT(const Matrix<T>& plM) : Matrix<T>(4,4) {
   if(plM.rows() == 4 && plM.cols() == 4)
@@ -111,6 +112,7 @@
   \author Philippe Lavoie 
   \date 25 July, 1997
  */
+template<>
 template <class T>
 MatrixRT<T>::MatrixRT(T* p) : Matrix<T>(p,4,4) {
   // nothing to do, p should have all the proper data.
@@ -144,33 +146,33 @@
   t10 = cos(ax);
   t13 = t4*t6;
 #ifdef COLUMN_ORDER
-  m[0] = t1*t2;
-  m[4] = -t4*t2;
-  m[8] = t6;
-  m[12] = 0 ;
-  m[1] = t7*t8+t4*t10;
-  m[5] = -t13*t8+t1*t10;
-  m[9] = -t2*t8;
-  m[13] = 0 ;
-  m[2] = -t7*t10+t4*t8;
-  m[6] = t13*t10+t1*t8;
-  m[10] = t2*t10;
-  m[14] = m[3] = m[7] = m[11] = 0.0 ;
-  m[15] = 1.0 ;
+  this->m[0] = t1*t2;
+  this->m[4] = -t4*t2;
+  this->m[8] = t6;
+  this->m[12] = 0 ;
+  this->m[1] = t7*t8+t4*t10;
+  this->m[5] = -t13*t8+t1*t10;
+  this->m[9] = -t2*t8;
+  this->m[13] = 0 ;
+  this->m[2] = -t7*t10+t4*t8;
+  this->m[6] = t13*t10+t1*t8;
+  this->m[10] = t2*t10;
+  this->m[14] = this->m[3] = this->m[7] = this->m[11] = 0.0 ;
+  this->m[15] = 1.0 ;
 #else
-  m[0] = t1*t2;
-  m[1] = -t4*t2;
-  m[2] = t6;
-  m[3] = 0 ;
-  m[4] = t7*t8+t4*t10;
-  m[5] = -t13*t8+t1*t10;
-  m[6] = -t2*t8;
-  m[7] = 0 ;
-  m[8] = -t7*t10+t4*t8;
-  m[9] = t13*t10+t1*t8;
-  m[10] = t2*t10;
-  m[11] = m[12] = m[13] = m[14] = 0 ;
-  m[15] = 1.0 ;
+  this->m[0] = t1*t2;
+  this->m[1] = -t4*t2;
+  this->m[2] = t6;
+  this->m[3] = 0 ;
+  this->m[4] = t7*t8+t4*t10;
+  this->m[5] = -t13*t8+t1*t10;
+  this->m[6] = -t2*t8;
+  this->m[7] = 0 ;
+  this->m[8] = -t7*t10+t4*t8;
+  this->m[9] = t13*t10+t1*t8;
+  this->m[10] = t2*t10;
+  this->m[11] = this->m[12] = this->m[13] = this->m[14] = 0 ;
+  this->m[15] = 1.0 ;
 #endif
   return *this ;
 }
@@ -203,33 +205,33 @@
   t9 = (T)sin((double)ax);
   t17 = t4*t7;
 #ifdef COLUMN_ORDER
-  m[0] = t1*t2;
-  m[4] = -t4*t5+t8*t9;
-  m[8] = t4*t9+t8*t5;
-  m[12] = 0.0 ;
-  m[1] = t4*t2;
-  m[5] = t1*t5+t17*t9;
-  m[9] = -t1*t9+t17*t5;
-  m[13] = 0.0 ;
-  m[2] = -t7;
-  m[6] = t2*t9;
-  m[10] = t2*t5;
-  m[14] = m[3] = m[7] = m[11] = 0 ;
-  m[15] = 1.0 ;
+  this->m[0] = t1*t2;
+  this->m[4] = -t4*t5+t8*t9;
+  this->m[8] = t4*t9+t8*t5;
+  this->m[12] = 0.0 ;
+  this->m[1] = t4*t2;
+  this->m[5] = t1*t5+t17*t9;
+  this->m[9] = -t1*t9+t17*t5;
+  this->m[13] = 0.0 ;
+  this->m[2] = -t7;
+  this->m[6] = t2*t9;
+  this->m[10] = t2*t5;
+  this->m[14] = this->m[3] = this->m[7] = this->m[11] = 0 ;
+  this->m[15] = 1.0 ;
 #else
-  m[0] = t1*t2;
-  m[1] = -t4*t5+t8*t9;
-  m[2] = t4*t9+t8*t5;
-  m[3] = 0.0 ;
-  m[4] = t4*t2;
-  m[5] = t1*t5+t17*t9;
-  m[6] = -t1*t9+t17*t5;
-  m[7] = 0.0 ;
-  m[8] = -t7;
-  m[9] = t2*t9;
-  m[10] = t2*t5;
-  m[11] = m[12] = m[13] = m[14] = 0 ;
-  m[15] = 1.0 ;
+  this->m[0] = t1*t2;
+  this->m[1] = -t4*t5+t8*t9;
+  this->m[2] = t4*t9+t8*t5;
+  this->m[3] = 0.0 ;
+  this->m[4] = t4*t2;
+  this->m[5] = t1*t5+t17*t9;
+  this->m[6] = -t1*t9+t17*t5;
+  this->m[7] = 0.0 ;
+  this->m[8] = -t7;
+  this->m[9] = t2*t9;
+  this->m[10] = t2*t5;
+  this->m[11] = this->m[12] = this->m[13] = this->m[14] = 0 ;
+  this->m[15] = 1.0 ;
 #endif
   return *this ;
 }
@@ -245,16 +247,16 @@
  */
 template <class T>
 MatrixRT<T>& MatrixRT<T>::translate(T x, T y, T z){
-  reset(0) ;
-  diag(1.0) ;
+  this->reset(0) ;
+  this->diag(1.0) ;
 #ifdef COLUMN_ORDER
-  m[12] = x ;
-  m[13] = y ;
-  m[14] = z ;
+  this->m[12] = x ;
+  this->m[13] = y ;
+  this->m[14] = z ;
 #else
-  m[3] = x ;
-  m[7] = y ;
-  m[11] = z ;
+  this->m[3] = x ;
+  this->m[7] = y ;
+  this->m[11] = z ;
 #endif
   return *this ;
 }
@@ -271,11 +273,11 @@
  */
 template <class T>
 MatrixRT<T>& MatrixRT<T>::scale(T x, T y, T z){
-  reset(0) ;
-  m[0] = x ;
-  m[5] = y ;
-  m[10] = z ;
-  m[15] = 1.0 ;
+  this->reset(0) ;
+  this->m[0] = x ;
+  this->m[5] = y ;
+  this->m[10] = z ;
+  this->m[15] = 1.0 ;
   return *this ;
 }
 
@@ -416,7 +418,7 @@
     error.fatal() ;
   }
   T *a,*b ;
-  a = m-1 ;
+  a = this->m-1 ;
   b = M[0] - 1 ;
   for(int i=0;i<16;++i){
     *(++a) = *(++b) ;
@@ -435,7 +437,7 @@
 template <class T>
 MatrixRT<T>& MatrixRT<T>::operator=(const MatrixRT<T>& M) {
   T *a,*b ;
-  a = m-1 ;
+  a = this->m-1 ;
   b = M.m - 1 ;
   for(int i=0;i<16;++i){
     *(++a) = *(++b) ;
Only in /home/makerpm/nurbs++-3.0.11/nurbs: matrixRT.lo
Only in /home/makerpm/nurbs++-3.0.11/nurbs: matrixRT.o
diff -ur ./nurbs/nurbs.cpp /home/makerpm/nurbs++-3.0.11/nurbs/nurbs.cpp
--- ./nurbs/nurbs.cpp	2002-05-25 03:25:49.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/nurbs/nurbs.cpp	2009-01-24 03:06:01.000000000 +1100
@@ -102,6 +102,7 @@
   \author Philippe Lavoie 
   \date 24 January 1997
 */
+template<>
 template <class T, int N>
 NurbsCurve<T,N>::NurbsCurve(const Vector< HPoint_nD<T,N> >& P1, const Vector<T> &U1, int Degree): P(P1), U(U1), deg_(Degree) 
 {
@@ -131,6 +132,7 @@
   \author Philippe Lavoie 
   \date 24 January 1997
 */
+template<>
 template <class T, int N>
 NurbsCurve<T,N>::NurbsCurve(const Vector< Point_nD<T,N> >& P1, const Vector<T>& W, const Vector<T>& U1, int Degree): P(P1.n()), U(U1), deg_(Degree)
 {
@@ -177,6 +179,7 @@
   \author Philippe Lavoie 
   \date 24 January 1997
 */
+template<>
 template <class T, int N>
 NurbsCurve<T,N>& NurbsCurve<T,N>::operator=(const NurbsCurve<T,N>& curve) {
   if(curve.U.n() != curve.P.n()+curve.deg_+1){
@@ -222,6 +225,7 @@
   \author Philippe Lavoie 
   \date 24 January 1997
 */
+template<>
 template <class T, int N>
 void NurbsCurve<T,N>::drawImg(Image_UBYTE& Img,unsigned char color,T step){
   Point_nD<T,N> a1,a2 ;
@@ -263,6 +267,7 @@
   \author Philippe Lavoie 
   \date 24 January 1997
 */
+template<>
 template <class T, int N>
 void NurbsCurve<T,N>::drawImg(Image_Color& Img,const Color& color,T step){
   Point_nD<T,N> a1,a2 ;
@@ -306,6 +311,7 @@
   \author Philippe Lavoie 
   \date 25 July 1997
 */
+template<>
 template <class T, int N>
 void NurbsCurve<T,N>::drawAaImg(Image_Color& Img, const Color& color, int precision, int alpha){
   NurbsCurve<T,3> profile ;
@@ -335,6 +341,7 @@
   \author Philippe Lavoie 
   \date 22 August 1997
 */
+template<>
 template <class T, int N>
 void NurbsCurve<T,N>::drawAaImg(Image_Color& Img, const Color& color, const NurbsCurve<T,3>& profile, int precision, int alpha){
   Vector< HPoint_nD<T,3> > sPts(2) ;
@@ -378,7 +385,7 @@
   \author Philippe Lavoie 
   \date 25 July 1997
 */
-template <class T, int N>
+template<> template <class T, int N>
 NurbsSurface<T,3> NurbsCurve<T,N>::drawAaImg(Image_Color& Img, const Color& color, const NurbsCurve<T,3>& profile, const NurbsCurve<T,3>& scaling, int precision, int alpha){
   Matrix<T> addMatrix ;
   Matrix_INT nMatrix ;
@@ -391,9 +398,9 @@
   T du,dv ;
   // compute a coarse distance for the curve
   Point_nD<T,N> a,b,c ;
-  a = pointAt(0.0) ;
-  b = pointAt(0.5) ;
-  c = pointAt(1.0) ;
+  a = this->pointAt(0.0) ;
+  b = this->pointAt(0.5) ;
+  c = this->pointAt(1.0) ;
 
   T distance = norm(b-a) + norm(c-b) ;
 
@@ -464,7 +471,7 @@
   \author Philippe Lavoie 
   \date 22 August 1997
 */
-template <class T, int N>
+template<> template <class T, int N>
 void NurbsCurve<T,N>::transform(const MatrixRT<T>& A){
   for(int i=P.n()-1;i>=0;--i)
     P[i] = A*P[i] ;
@@ -495,7 +502,7 @@
   \author Philippe Lavoie 
   \date 24 January, 1997
 */
-template <class T, int N>
+template<> template <class T, int N>
 HPoint_nD<T,N> NurbsCurve<T,N>::operator()(T u) const{
   static Vector<T> Nb ;
   int span = findSpan(u) ;
@@ -534,7 +541,7 @@
   \author Philippe Lavoie    
   \date 24 January, 1997
 */
-template <class T, int N>
+template<> template <class T, int N>
 HPoint_nD<T,N> NurbsCurve<T,N>::hpointAt(T u, int span) const{
   static Vector<T> Nb ;
 
@@ -563,6 +570,7 @@
    \author  Philippe Lavoie
    \date 24 January, 1997
 */
+template<>
 template <class T, int N>
 Point_nD<T,N> NurbsCurve<T,N>::derive3D(T u, int d) const {
   Vector< Point_nD<T,N> > ders ;
@@ -586,7 +594,7 @@
   \author  Philippe Lavoie
   \date 24 January, 1997
 */
-template <class T, int N>
+template<> template <class T, int N>
 HPoint_nD<T,N> NurbsCurve<T,N>::derive(T u, int d) const {
   Vector< HPoint_nD<T,N> > ders ;
   deriveAtH(u,d,ders) ;
@@ -609,7 +617,7 @@
   \author  Philippe Lavoie
   \date 24 January, 1997
 */
-template <class T, int N>
+template<> template <class T, int N>
 void NurbsCurve<T,N>::deriveAtH(T u,int d, Vector< HPoint_nD<T,N> >& ders) const{
   int du = minimum(d,deg_) ;
   int span ;
@@ -641,6 +649,7 @@
   \author    Philippe Lavoie    
   \date 9 October, 1998
 */
+template<>
 template <class T, int N>
 void NurbsCurve<T,N>::deriveAtH(T u, int d, int span, Vector< HPoint_nD<T,N> >& ders) const{
   int du = minimum(d,deg_) ;
@@ -712,6 +721,7 @@
   \author Philippe Lavoie
   \date 24 January, 1997
 */
+template<>
 template <class T, int N>
 void NurbsCurve<T,N>::deriveAt(T u, int d, Vector< Point_nD<T,N> >& ders) const{
   Vector< HPoint_nD<T,N> > dersW ;
@@ -752,6 +762,7 @@
   \author Philippe Lavoie     
   \date 9 October 1998
 */
+template<>
 template <class T, int N>
 void NurbsCurve<T,N>::deriveAt(T u, int d, int span, Vector< Point_nD<T,N> >& ders) const{
   Vector< HPoint_nD<T,N> > dersW ;
@@ -796,6 +807,7 @@
   \author Philippe Lavoie    
   \date 2 September, 1997
 */
+template<>
 template <class T, int N>
 Point_nD<T,N> NurbsCurve<T,N>::normal(T u, const Point_nD<T,N>& v) const{
   return crossProduct(firstDn(u),v) ;
@@ -841,6 +853,7 @@
   \author Philippe Lavoie 
   \date 24 January 1997
 */
+template<>
 template <class T, int D>
 T NurbsCurve<T,D>::basisFun(T u, int i, int p) const{
   T Nip ;
@@ -913,6 +926,7 @@
   \author Philippe Lavoie 
   \date 24 January 1997
 */
+template<>
 template <class T, int N>
 void NurbsCurve<T,N>::dersBasisFuns(int n,T u, int span, Matrix<T>& ders) const {
   T* left = (T*) alloca(2*(deg_+1)*sizeof(T)) ;
@@ -1050,6 +1064,7 @@
    \author Philippe Lavoie 
    \date 24 January 1997
 */
+template<>
 template <class T, int D>
 void NurbsCurve<T,D>::basisFuns(T u, int i, Vector<T>& N) const{
   T* left = (T*) alloca(2*(deg_+1)*sizeof(T)) ;
@@ -1088,6 +1103,7 @@
   \date 24 January 1997
   \modified 20 January, 1999 (Alejandro Frangi)
 */
+template<>
 template <class T, int N>
 int NurbsCurve<T,N>::findSpan(T u) const{
   if(u>=U[P.n()]) 
@@ -1122,6 +1138,7 @@
   \author    Philippe Lavoie      
   \date 24 January, 1997
 */
+template<>
 template <class T, int N>
 int NurbsCurve<T,N>::findKnot(T u) const{
   if(u==U[P.n()])
@@ -1143,6 +1160,7 @@
   \author  Philippe Lavoie
   \date 24 January, 1997
 */
+template<>
 template <class T, int N>
 int NurbsCurve<T,N>::findMult(int r) const {
   int s=1 ;
@@ -1169,6 +1187,7 @@
   \author Philippe Lavoie
   \date 24 January, 1997
 */
+template<>
 template <class T, int N>
 void NurbsCurve<T,N>::findMultSpan(T u, int& r, int& s) const {
   r = findKnot(u) ;
@@ -1191,6 +1210,7 @@
   \author Philippe Lavoie 
   \date 24 January 1997
 */
+template<>
 template <class T, int N>
 void NurbsCurve<T,N>::resize(int n, int Deg){
   deg_ = Deg ;
@@ -1233,6 +1253,7 @@
   \author Philippe Lavoie   
   \date 24 January, 1997
 */
+template<>
 template <class T, int N>
 int NurbsCurve<T,N>::leastSquares(const Vector< Point_nD<T,N> >& Q, int degC, int n){
   Vector<T> ub(Q.n()) ;
@@ -1277,6 +1298,7 @@
   \author Philippe Lavoie 
   \date 24 January 1997
 */
+template<>
 template <class T, int N>
 int NurbsCurve<T,N>::leastSquares(const Vector< Point_nD<T,N> >& Q, int degC, int n, const Vector<T>& ub){
   int i,j;
@@ -1354,6 +1376,7 @@
   \author Philippe Lavoie 
   \date 24 January 1997
 */
+template<>
 template <class T, int N>
 int NurbsCurve<T,N>::leastSquaresH(const Vector< HPoint_nD<T,N> >& Q, int degC, int n, const Vector<T>& ub){
   int i,j;
@@ -1434,6 +1457,7 @@
   \author Philippe Lavoie 
   \date 24 January 1997
 */
+template<>
 template <class T, int D>
 int NurbsCurve<T,D>::leastSquares(const Vector< Point_nD<T,D> >& Q, int degC, int n, const Vector<T>& ub, const Vector<T>& knot){
   int i,j,span;
@@ -1569,6 +1593,7 @@
   \author Philippe Lavoie 
   \date 24 January 1997
 */
+template<>
 template <class T, int D>
 int NurbsCurve<T,D>::leastSquaresH(const Vector< HPoint_nD<T,D> >& Q, int degC, int n, const Vector<T>& ub, const Vector<T>& knot){
   int i,j,span,m ;
@@ -1682,6 +1707,7 @@
   \author    Philippe Lavoie 
   \date 24 January, 1997
 */
+template<>
 template <class T, int N>
 T NurbsCurve<T,N>::getRemovalBnd(int r, int s ) const{
   Vector< HPoint_nD<T,N> > temp(U.rows()) ;
@@ -1734,6 +1760,7 @@
   \author Philippe Lavoie 
   \date 24 January 1997
 */
+template<>
 template <class T, int N>
 void NurbsCurve<T,N>::removeKnot(int  r, int s, int num)
 {
@@ -1821,6 +1848,7 @@
   \author Philippe Lavoie 
   \date 24 January 1997
 */
+template<>
 template <class T, int N>
 void NurbsCurve<T,N>::removeKnotsBound(const Vector<T>& ub,
 				    Vector<T>& ek, T E){
@@ -2098,6 +2126,7 @@
   \author Philippe Lavoie 
   \date 24 January 1997
 */
+template<>
 template <class T, int N>
 void NurbsCurve<T,N>::globalApproxErrBnd(Vector< Point_nD<T,N> >& Q, int degC, T E){
   Vector<T> ub(Q.n()) ;
@@ -2127,6 +2156,7 @@
   \author Philippe Lavoie 
   \code 24 January 1997
 */
+template<>
 template <class T, int N>
 void NurbsCurve<T,N>::globalApproxErrBnd(Vector< Point_nD<T,N> >& Q, Vector<T>& ub, int degC, T E){
   Vector<T> ek(Q.n()) ;
@@ -2224,6 +2254,7 @@
   \author Philippe Lavoie 
   \date 24 January 1997
 */
+template<>
 template <class T, int N>
 void NurbsCurve<T,N>::globalApproxErrBnd2(Vector< Point_nD<T,N> >& Q,
 				       int degC,
@@ -2284,6 +2315,7 @@
   \author Philippe Lavoie 
   \date 24 January 1997
 */
+template<>
 template <class T, int N>
 void NurbsCurve<T,N>::globalApproxErrBnd3(Vector< Point_nD<T,N> >& Q,int degC,T E){
   //NurbsCurve<T,N> tCurve(1) ;
@@ -2333,6 +2365,7 @@
   \author Philippe Lavoie 
   \date 24 January 1997
 */
+template<>
 template <class T, int N>
 void NurbsCurve<T,N>::globalApproxErrBnd3(Vector< Point_nD<T,N> >& Q, 
 				       const Vector<T> &ub,
@@ -2378,6 +2411,7 @@
   \author Philippe Lavoie 
   \date 24 January 1997
 */
+template<>
 template <class T, int N>
 void NurbsCurve<T,N>::projectTo(const Point_nD<T,N>& p, T guess, T& u, Point_nD<T,N>& r, T e1, T e2,int maxTry) const{
   T un ;
@@ -2437,6 +2471,7 @@
   \author Philippe Lavoie
   \date 24 January, 1997
 */
+template<>
 template <class T, int N>
 void NurbsCurve<T,N>::degreeElevate(int t){
   if(t<=0){
@@ -2615,6 +2650,7 @@
   \author Philippe Lavoie
   \date 24 January 1997
 */
+template<>
 template <class T, int N>
 int NurbsCurve<T,N>::knotInsertion(T u, int r,NurbsCurve<T,N>& nc){
   // Compute k and s      u = [ u_k , u_k+1)  with u_k having multiplicity s
@@ -2710,6 +2746,7 @@
   \author Philippe Lavoie     
   \date 24 January, 1997
 */
+template<>
 template <class T, int N>
 void NurbsCurve<T,N>::refineKnotVector(const Vector<T>& X){
   int n = P.n()-1 ;
@@ -2769,6 +2806,7 @@
   \author Philippe Lavoie
   \date 24 January, 1997
 */
+template<>
 template <class T, int N>
 void NurbsCurve<T,N>::globalInterp(const Vector< Point_nD<T,N> >& Q, int d){
   Vector<T> ub ;
@@ -2791,6 +2829,7 @@
   \author Philippe Lavoie
   \date 24 January, 1997
 */
+template<>
 template <class T, int D>
 void NurbsCurve<T,D>::globalInterp(const Vector< Point_nD<T,D> >& Q, const Vector<T>& ub, int d){
   int i,j ;
@@ -2884,6 +2923,7 @@
   \author Philippe Lavoie 
   \date 3 September, 1997
 */
+template<>
 template <class T, int nD>
 void NurbsCurve<T,nD>::globalInterpD(const Vector< Point_nD<T,nD> >& Q, const Vector< Point_nD<T,nD> >& D, int d, int unitD, T a){
   int i,j,n ;
@@ -3073,6 +3113,7 @@
   \author  Philippe Lavoie
   \date 24 January, 1997
 */
+template<>
 template <class T, int D>
 void NurbsCurve<T,D>::globalInterpH(const Vector< HPoint_nD<T,D> >& Q, int d){
   int i,j ;
@@ -3139,6 +3180,7 @@
   \author    Philippe Lavoie
   \date 24 January, 1997
 */
+template<>
 template <class T, int D>
 void NurbsCurve<T,D>::globalInterpH(const Vector< HPoint_nD<T,D> >& Q, const Vector<T>& Uc, int d){
   int i,j ;
@@ -3208,6 +3250,7 @@
   \author    Philippe Lavoie
   \date 24 January, 1997
 */
+template<>
 template <class T, int D>
 void NurbsCurve<T,D>::globalInterpH(const Vector< HPoint_nD<T,D> >& Q, const Vector<T>& ub, const Vector<T>& Uc, int d){
   int i,j ;
@@ -3355,6 +3398,7 @@
   \author Philippe Lavoie
   \date 25 July, 1997
 */
+template<>
 template <class T, int N>
 void NurbsCurve<T,N>::makeCircle(const Point_nD<T,N>& O, const Point_nD<T,N>& X, const Point_nD<T,N>& Y, T r, double as, double ae){
   double theta,angle,dtheta ;
@@ -3437,6 +3481,7 @@
   \author Philippe Lavoie
   \date 25 July, 1997
 */
+template<>
 template <class T, int N>
 void NurbsCurve<T,N>::makeCircle(const Point_nD<T,N>& O, T r, double as, double ae){
   makeCircle(O,Point_nD<T,N>(1,0,0),Point_nD<T,N>(0,1,0),r,as,ae) ;
@@ -3454,6 +3499,7 @@
   \author Philippe Lavoie
   \date 3 May, 1999
 */
+template<>
 template <class T, int N>
 void NurbsCurve<T,N>::makeCircle(const Point_nD<T,N>& O, T r){
   resize(9,2);
@@ -3544,6 +3590,7 @@
   \author    Philippe Lavoie
   \date 24 January, 1997
 */
+template<>
 template <class T, int N>
 void NurbsCurve<T,N>::mergeKnotVector(const Vector<T> &Um){
   int i,ia,ib ;
@@ -3621,6 +3668,7 @@
   \author Philippe Lavoie
   \date 24 January 1997
 */
+template<>
 template <class T, int N>
 int NurbsCurve<T,N>::read(ifstream &fin){
   if(!fin) {
@@ -3692,6 +3740,7 @@
   \author Philippe Lavoie
   \date 24 January 1997
 */
+template<>
 template <class T, int N>
 int NurbsCurve<T,N>::read(const char* filename){
   ifstream fin(filename) ;
@@ -3710,6 +3759,7 @@
   \author Philippe Lavoie
   \date 24 January 1997
 */
+template<>
 template <class T, int N>
 int NurbsCurve<T,N>::write(const char* filename) const {
   ofstream fout(filename) ;  
@@ -3728,6 +3778,7 @@
   \author Philippe Lavoie 
   \date 24 January 1997
 */
+template<>
 template <class T, int N>
 int NurbsCurve<T,N>::write(ofstream &fout) const {
   if(!fout)
diff -ur ./nurbs/nurbsGL.cpp /home/makerpm/nurbs++-3.0.11/nurbs/nurbsGL.cpp
--- ./nurbs/nurbsGL.cpp	2002-05-14 07:07:46.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/nurbs/nurbsGL.cpp	2009-01-24 03:06:01.000000000 +1100
@@ -26,7 +26,7 @@
 #include <nurbsGL.h>
 #include <string.h>
 #include <stdio.h>
-#include <iostream.h> 
+#include <iostream> 
 
 #ifdef WITH_OPENGL
 
Only in /home/makerpm/nurbs++-3.0.11/nurbs: nurbsGL.lo
Only in /home/makerpm/nurbs++-3.0.11/nurbs: nurbsGL.o
diff -ur ./nurbs/nurbsS.cpp /home/makerpm/nurbs++-3.0.11/nurbs/nurbsS.cpp
--- ./nurbs/nurbsS.cpp	2002-05-14 07:07:46.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/nurbs/nurbsS.cpp	2009-01-24 03:06:01.000000000 +1100
@@ -3762,12 +3762,12 @@
   // we use and angle of 36 to view the object
   // and position the rest according to this.
   Point_nD<T,N> minP, maxP ;
-  minP.x() = extremum(1,coordX) ;
-  minP.y() = extremum(1,coordY) ;
-  minP.z() = extremum(1,coordZ) ;
-  maxP.x() = extremum(0,coordX) ;
-  maxP.y() = extremum(0,coordY) ;
-  maxP.z() = extremum(0,coordZ) ;
+  minP.x() = this->extremum(1,coordX) ;
+  minP.y() = this->extremum(1,coordY) ;
+  minP.z() = this->extremum(1,coordZ) ;
+  maxP.x() = this->extremum(0,coordX) ;
+  maxP.y() = this->extremum(0,coordY) ;
+  maxP.z() = this->extremum(0,coordZ) ;
 
   Point_nD<T,N> lookAt  ;
   lookAt.x() = (minP.x()+maxP.x())/2.0 ;
@@ -3860,12 +3860,12 @@
   // we use and angle of 36 to view the object
   // and position the rest according to this.
   Point_nD<T,N> minP, maxP ;
-  minP.x() = extremum(1,coordX) ;
-  minP.y() = extremum(1,coordY) ;
-  minP.z() = extremum(1,coordZ) ;
-  maxP.x() = extremum(0,coordX) ;
-  maxP.y() = extremum(0,coordY) ;
-  maxP.z() = extremum(0,coordZ) ;
+  minP.x() = this->extremum(1,coordX) ;
+  minP.y() = this->extremum(1,coordY) ;
+  minP.z() = this->extremum(1,coordZ) ;
+  maxP.x() = this->extremum(0,coordX) ;
+  maxP.y() = this->extremum(0,coordY) ;
+  maxP.z() = this->extremum(0,coordZ) ;
 
   Point_nD<T,N> lookAt  ;
   lookAt.x() = (minP.x()+maxP.x())/2.0 ;
@@ -4045,12 +4045,12 @@
   }
 
   Point_nD<T,N> minP, maxP ;
-  minP.x() = extremum(1,coordX) ;
-  minP.y() = extremum(1,coordY) ;
-  minP.z() = extremum(1,coordZ) ;
-  maxP.x() = extremum(0,coordX) ;
-  maxP.y() = extremum(0,coordY) ;
-  maxP.z() = extremum(0,coordZ) ;
+  minP.x() = this->extremum(1,coordX) ;
+  minP.y() = this->extremum(1,coordY) ;
+  minP.z() = this->extremum(1,coordZ) ;
+  maxP.x() = this->extremum(0,coordX) ;
+  maxP.y() = this->extremum(0,coordY) ;
+  maxP.z() = this->extremum(0,coordZ) ;
 
   Point_nD<T,N> lookAt  ;
   lookAt.x() = (minP.x()+maxP.x())/2.0 ;
diff -ur ./nurbs/nurbs_sp.cpp /home/makerpm/nurbs++-3.0.11/nurbs/nurbs_sp.cpp
--- ./nurbs/nurbs_sp.cpp	2002-05-14 07:07:46.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/nurbs/nurbs_sp.cpp	2009-01-24 03:06:01.000000000 +1100
@@ -41,7 +41,7 @@
 */
 template <class T, int N>
 void NurbsCurveSP<T,N>::updateMaxU() {
-  if(deg_>3){
+  if(this->deg_>3){
 #ifdef USE_EXCEPTION
     throw NurbsInputError();
 #else
@@ -51,10 +51,10 @@
 #endif
   }
   else{
-    maxU.resize(P.n()) ;
-    maxAt_.resize(P.n()) ;
-    for(int i=0;i<P.n();++i){
-      if(!maxInfluence(i,U,deg_,maxAt_[i]))
+    maxU.resize(this->P.n()) ;
+    maxAt_.resize(this->P.n()) ;
+    for(int i=0;i<this->P.n();++i){
+      if(!maxInfluence(i,this->U,this->deg_,maxAt_[i]))
 	cerr << "Problem in maxInfluence U!\n" ;
       if(i>0)
 	if(maxAt_[i]<maxAt_[i-1]){
@@ -63,13 +63,13 @@
 #else
 	  Error error("Error updating maxU");
 	  error << "HUGE ERROR!\n" ;
-	  error << "Knot = " << U << endl ;
+	  error << "Knot = " << this->U << endl ;
 	  error << " i = " << i << endl ;
-	  error << " deg = " << deg_ << endl ;
+	  error << " this->deg = " << deg_ << endl ;
 	  error.fatal() ; 
 #endif
 	}
-      maxU[i] = basisFun(maxAt_[i],i,deg_) ;
+      maxU[i] = basisFun(maxAt_[i],i,this->deg_) ;
     }
     
   }
@@ -96,14 +96,14 @@
 */
 template <class T, int N>
 void NurbsCurveSP<T,N>::modOnlySurfCPby(int i, const HPoint_nD<T,N>& a){
-  Vector<T> u(2*deg_+3) ;
-  Vector< Point_nD<T,N> > pts(2*deg_+3) ; 
+  Vector<T> u(2*this->deg_+3) ;
+  Vector< Point_nD<T,N> > pts(2*this->deg_+3) ; 
 
   int n=0;
-  for(int j=i-deg_-1;j<=i+deg_+1;++j){
+  for(int j=i-this->deg_-1;j<=i+this->deg_+1;++j){
     if(j<0)
       continue ;
-    if(j>=P.n())
+    if(j>=this->P.n())
       break ; 
     u[n] = maxAt_[j] ;
     if( j == i){
diff -ur ./nurbs/nurbs_sp.h /home/makerpm/nurbs++-3.0.11/nurbs/nurbs_sp.h
--- ./nurbs/nurbs_sp.h	2002-05-18 04:24:21.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/nurbs/nurbs_sp.h	2009-01-24 03:06:01.000000000 +1100
@@ -72,7 +72,7 @@
   int read(ifstream &fin) ;
 
   void modSurfCPby(int i, const HPoint_nD<T,N>& a) 
-    { P[i] +=  a / maxU[i] ;  }
+    { this->P[i] +=  a / maxU[i] ;  }
   void modSurfCP(int i, const HPoint_nD<T,N>& a) 
     { modSurfCPby(i,a-surfP(i)) ;  }
 
diff -ur ./nurbs/nurbsS_sp.cpp /home/makerpm/nurbs++-3.0.11/nurbs/nurbsS_sp.cpp
--- ./nurbs/nurbsS_sp.cpp	2002-05-14 07:07:46.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/nurbs/nurbsS_sp.cpp	2009-01-24 03:06:01.000000000 +1100
@@ -43,7 +43,7 @@
 */
 template <class T, int N>
 void NurbsSurfaceSP<T,N>::updateMaxU() {
-  if(degU>3){
+  if(this->degU>3){
 #ifdef USE_EXCEPTION
     throw NurbsInputError();
 #else
@@ -53,12 +53,12 @@
 #endif
   }
   else{
-    maxU.resize(P.rows()) ;
-    maxAtU_.resize(P.rows()) ;
-    for(int i=0;i<P.rows();++i){
-      if(!maxInfluence(i,U,degU,maxAtU_[i]))
+    maxU.resize(this->P.rows()) ;
+    maxAtU_.resize(this->P.rows()) ;
+    for(int i=0;i<this->P.rows();++i){
+      if(!maxInfluence(i,this->U,this->degU,maxAtU_[i]))
 	cerr << "Problem in maxInfluence U!\n" ;
-      maxU[i] = nurbsBasisFun(maxAtU_[i],i,degU,U) ;
+      maxU[i] = nurbsBasisFun(maxAtU_[i],i,this->degU,this->U) ;
     }
     
   }
@@ -78,7 +78,7 @@
 */
 template <class T, int N>
 void NurbsSurfaceSP<T,N>::updateMaxV() {
-  if(degV>3){
+  if(this->degV>3){
 #ifdef USE_EXCEPTION
     throw NurbsInputError();
 #else
@@ -88,12 +88,12 @@
 #endif
   }
   else{
-    maxV.resize(P.cols()) ;
-    maxAtV_.resize(P.cols()) ;
-    for(int i=0;i<P.cols();++i){
-      if(!maxInfluence(i,V,degV,maxAtV_[i]))
+    maxV.resize(this->P.cols()) ;
+    maxAtV_.resize(this->P.cols()) ;
+    for(int i=0;i<this->P.cols();++i){
+      if(!maxInfluence(i,this->V,this->degV,maxAtV_[i]))
 	cerr << "Problem in maxInfluence V!\n" ;
-      maxV[i] = nurbsBasisFun(maxAtV_[i],i,degV,V) ;
+      maxV[i] = nurbsBasisFun(maxAtV_[i],i,this->degV,this->V) ;
     }
     
   }
@@ -124,11 +124,11 @@
 NurbsSurfaceSP<T,N> NurbsSurfaceSP<T,N>::generateParallel(T d) const {
   NurbsSurfaceSP<T,N> p(*this) ;
 
-  Vector< Point_nD<T,N> > offset(P.rows()*P.cols()) ;
-  Vector<T> ur(P.rows()*P.cols()) ;
-  Vector<T> vr(P.rows()*P.cols()) ;
-  Vector_INT Du(P.rows()*P.cols()) ;
-  Vector_INT Dv(P.rows()*P.cols()) ;
+  Vector< Point_nD<T,N> > offset(this->P.rows()*this->P.cols()) ;
+  Vector<T> ur(this->P.rows()*this->P.cols()) ;
+  Vector<T> vr(this->P.rows()*this->P.cols()) ;
+  Vector_INT Du(this->P.rows()*this->P.cols()) ;
+  Vector_INT Dv(this->P.rows()*this->P.cols()) ;
 
   Du.reset(0) ;
   Dv.reset(0) ;
@@ -137,8 +137,8 @@
 
   no = 0 ;
 
-  for(i=0;i<P.rows();++i)
-    for(j=0;j<P.cols();++j){
+  for(i=0;i<this->P.rows();++i)
+    for(j=0;j<this->P.cols();++j){
       Point_nD<T,N> norm ;
       norm = normal(maxAtU_[i],maxAtV_[j]) ;
       if(norm.x() == T(0) && 
@@ -155,19 +155,19 @@
 	  norm /= T(2) ;
 	  ok = 1 ;
 	}
-	if(i==P.rows()-1 && j==P.cols()-1){
+	if(i==this->P.rows()-1 && j==this->P.cols()-1){
 	  norm = normal(maxAtU_[i]-delta,maxAtV_[j]) ;
 	  norm += normal(maxAtU_[i],maxAtV_[j]-delta) ;
 	  norm /= T(2) ;
 	  ok = 1 ;
 	}
-	if(i==0 && j==P.cols()-1){
+	if(i==0 && j==this->P.cols()-1){
 	  norm = normal(maxAtU_[i]-delta,maxAtV_[j]) ;
 	  norm += normal(maxAtU_[i],maxAtV_[j]+delta) ;
 	  norm /= T(2) ;
 	  ok = 1 ;
 	}
-	if(i==P.rows()-1 && j==0){
+	if(i==this->P.rows()-1 && j==0){
 	  norm = normal(maxAtU_[i]-delta,maxAtV_[j]) ;
 	  norm += normal(maxAtU_[i],maxAtV_[j]+delta) ;
 	  norm /= T(2) ;
@@ -178,7 +178,7 @@
 	  while(norm.x() == T(0) && 
 	     norm.y() == T(0) &&
 	     norm.z() == T(0)){
-	    if( nt*d >(U[U.n()-1]-U[0])){
+	    if( nt*d >(this->U[this->U.n()-1]-this->U[0])){
 #ifdef USE_EXCEPTION
 	      throw NurbsComputationError();
 #else
@@ -188,12 +188,12 @@
 #endif
 	    }
 	    T u1,u2,v1,v2 ;
-	    if(i==0 || i==P.rows()-1){
+	    if(i==0 || i==this->P.rows()-1){
 	      u1 = u2 = maxAtU_[i] ;
 	      v1 = maxAtV_[j]+ nt*delta ;
 	      v2 = maxAtV_[j]- nt*delta ;
-	      if(v1>V[V.n()-1]) v1 = V[V.n()-1] ;
-	      if(v2<V[0]) v2 = V[0] ;
+	      if(v1>this->V[this->V.n()-1]) v1 = this->V[this->V.n()-1] ;
+	      if(v2<this->V[0]) v2 = this->V[0] ;
 	      norm = normal(u1,v1);
 	      norm += normal(u2,v2) ;
 	      norm /= 2 ; 
@@ -202,8 +202,8 @@
 	      u1 = maxAtU_[i]- nt*delta ;
 	      u2 = maxAtU_[i]+ nt*delta ;
 	      v1 = v2 = maxAtV_[j] ;
-	      if(u1 < U[0]) u1 = U[0] ;
-	      if(u2 > U[U.n()-1]) u2 = U[U.n()-1] ;
+	      if(u1 < this->U[0]) u1 = this->U[0] ;
+	      if(u2 > this->U[this->U.n()-1]) u2 = this->U[this->U.n()-1] ;
 
 	      T u3,v3 ;
 	      u3 = maxAtU_[i] ;
@@ -212,8 +212,8 @@
 	      else
 		v3 = maxAtV_[j]- nt*delta ;
 
-	      if(v3<V[0]) v3 = V[0] ;
-	      if(v3>V[V.n()-1]) v3 = V[V.n()-1] ;
+	      if(v3<this->V[0]) v3 = this->V[0] ;
+	      if(v3>this->V[this->V.n()-1]) v3 = this->V[this->V.n()-1] ;
 
 	      norm = normal(u1,v1);
 	      norm += normal(u2,v2) ;
@@ -263,13 +263,13 @@
 
   int sizeU, sizeV ;
 
-  sizeU = 2*degU+3 ; 
-  if(i-degU-1<0) sizeU += i-degU-1 ; 
-  if(i+degU+1>=P.rows()) sizeU -= i+degU+1-P.rows() ;
-
-  sizeV = 2*degV+3 ;
-  if(j-degV-1<0) sizeV += j-degV-1 ; 
-  if(j+degV+1>=P.cols()) sizeV -= j+degV+1-P.cols() ;
+  sizeU = 2*this->degU+3 ; 
+  if(i-this->degU-1<0) sizeU += i-this->degU-1 ; 
+  if(i+this->degU+1>=this->P.rows()) sizeU -= i+this->degU+1-this->P.rows() ;
+
+  sizeV = 2*this->degV+3 ;
+  if(j-this->degV-1<0) sizeV += j-this->degV-1 ; 
+  if(j+this->degV+1>=this->P.cols()) sizeV -= j+this->degV+1-this->P.cols() ;
   
   Vector<T> u(sizeU) ;
   Vector<T> v(sizeV) ;
@@ -280,16 +280,16 @@
   int n=0;
   int nu = 0 ;
   int nv = 0 ; 
-  for(int k=i-degU-1;k<=i+degU+1;++k){
+  for(int k=i-this->degU-1;k<=i+this->degU+1;++k){
     if(k<0)
       continue ;
-    if(k>=P.rows())
+    if(k>=this->P.rows())
       break ; 
     nv = 0 ;
-    for(int l=j-degV-1;l<=j+degV+1;++l){
+    for(int l=j-this->degV-1;l<=j+this->degV+1;++l){
       if(l<0)
 	continue ;
-      if(l>=P.cols())
+      if(l>=this->P.cols())
 	break ; 
       if( k == i && j==l){
 	pts[n].x() = a.x() ; 
diff -ur ./nurbs/nurbsS_sp.h /home/makerpm/nurbs++-3.0.11/nurbs/nurbsS_sp.h
--- ./nurbs/nurbsS_sp.h	2002-05-14 07:07:46.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/nurbs/nurbsS_sp.h	2009-01-24 03:06:01.000000000 +1100
@@ -78,7 +78,7 @@
 
 
   void modSurfCPby(int i, int j, const HPoint_nD<T,N>& a) //!< Moves a surface point by a value
-    { P(i,j) +=  a / (maxU[i]*maxV[j]) ;  }
+    { this->P(i,j) +=  a / (maxU[i]*maxV[j]) ;  }
   void modSurfCP(int i, int j, const HPoint_nD<T,N>& a) //!< Moves a surface point to a value
     { modSurfCPby(i,j,a-surfP(i,j)) ;  }
 
diff -ur ./nurbs/nurbsSub.cpp /home/makerpm/nurbs++-3.0.11/nurbs/nurbsSub.cpp
--- ./nurbs/nurbsSub.cpp	2002-05-14 07:07:46.000000000 +1000
+++ /home/makerpm/nurbs++-3.0.11/nurbs/nurbsSub.cpp	2009-01-24 03:06:01.000000000 +1100
@@ -904,7 +904,7 @@
   
   /* Allocate storage for the grid of points generated */
   
-  CHECK( pts = new (SurfSample<T>*)[Granularity+1]);
+  CHECK( pts = new SurfSample<T>*[Granularity+1]);
   CHECK( pts[0] = new SurfSample<T>[(Granularity+1)*(Granularity+1)]);
   
   for (i = 1; i <= Granularity; i++)
@@ -983,7 +983,7 @@
   
   if (! *alpha)	/* Must allocate alpha */
     {
-      CHECK( *alpha = new (T*)[k+1]);
+      CHECK( *alpha = new T*[k+1]);
       for (i = 0; i <= k; i++)
 	CHECK( (*alpha)[i] = new T[(m + n + 1)]);
     }
Only in /home/makerpm/nurbs++-3.0.11/: nurbs++-config
Only in /home/makerpm/nurbs++-3.0.11/tests: Makefile
Only in /home/makerpm/nurbs++-3.0.11/tests/matrix: .deps
Only in /home/makerpm/nurbs++-3.0.11/tests/matrix: Makefile
Only in /home/makerpm/nurbs++-3.0.11/tests/nurbs: .deps
Only in /home/makerpm/nurbs++-3.0.11/tests/nurbs: Makefile
