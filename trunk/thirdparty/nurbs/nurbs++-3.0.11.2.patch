diff -uNr OLD/nurbs++-3.0.11/include/plib_config.h nurbs++-3.0.11/include/plib_config.h
--- OLD/nurbs++-3.0.11/include/plib_config.h	2009-08-17 17:04:53.000000000 +0200
+++ nurbs++-3.0.11/include/plib_config.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,120 +0,0 @@
-/* include/plib_config.h.  Generated by configure.  */
-/* include/plib_config.h.in.  Generated from configure.in by autoheader.  */
-// define if you want to use exception handling
-#define USE_EXCEPTION 1
-
-// define if you want verbose exception handling
-/* #undef VERBOSE_EXCEPTION */
-
-// define if you have the ISO C++ friend declaration style
-#define HAVE_ISO_FRIEND_DECL 1
-
-// define if you can handle the template of template class
-#define HAVE_TEMPLATE_OF_TEMPLATE 1
-
-// define if you can use -fno-implicit-template
-#define NO_IMPLICIT_TEMPLATES 1
-
-// define if you can use -frepo
-/* #undef INCLUDE_TEMPLATE_SOURCE */
-
-// define if you want Image Magick
-/* #undef WITH_IMAGE_MAGICK */
-
-// define if you want to do range validity checking
-// and also other debugging functions
-#define DEBUG_PLIB 1
-
-// Define if you want the matrix to be in column order rather than row order.
-// Column ordering is used by fortran and OpenGL.
-/* #undef COLUMN_ORDER */
-
-// the name of the package
-#define PACKAGE "nurbs++"
-
-// the version of the package
-#define VERSION "3.0.11"
-
-// if the C++ compiler supports namespaces
-#define HAVE_NAMESPACE 1
-
-// Specify if OpenGL is present on this system
-/* #undef WITH_OPENGL */
-
-// Specify if you are using Solaris with egcs
-/* #undef USING_GNU_SOLARIS */
-
-// Specify if you are using DEC Alpha with egcs
-/* #undef USING_GNU_DECALPHA */
-
-// Specify if you are using SGI with egcs
-/* #undef USING_GNU_SGI */
-
-// Specify if you are using Linux (assumed with egcs)
-#define USING_LINUX 1
-
-// Specify if you have CppUnit installed
-/* #undef HAS_CPPUNIT */
-
-// Specify if you have abs defined for the Complex type
-#define HAS_COMPLEX_ABS 1
-
-// Specify if you have conf defined for the Complex type
-#define HAS_COMPLEX_CONJ 1
-
-/* Define to 1 if you have the <dlfcn.h> header file. */
-#define HAVE_DLFCN_H 1
-
-/* Define to 1 if you have the <inttypes.h> header file. */
-#define HAVE_INTTYPES_H 1
-
-/* Define to 1 if you have the <memory.h> header file. */
-#define HAVE_MEMORY_H 1
-
-/* Define to 1 if you have the <stdint.h> header file. */
-#define HAVE_STDINT_H 1
-
-/* Define to 1 if you have the <stdlib.h> header file. */
-#define HAVE_STDLIB_H 1
-
-/* Define to 1 if you have the <strings.h> header file. */
-#define HAVE_STRINGS_H 1
-
-/* Define to 1 if you have the <string.h> header file. */
-#define HAVE_STRING_H 1
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#define HAVE_SYS_STAT_H 1
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#define HAVE_SYS_TYPES_H 1
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#define HAVE_UNISTD_H 1
-
-/* Name of package */
-#define PACKAGE "nurbs++"
-
-/* Define to the address where bug reports for this package should be sent. */
-#define PACKAGE_BUGREPORT ""
-
-/* Define to the full name of this package. */
-#define PACKAGE_NAME ""
-
-/* Define to the full name and version of this package. */
-#define PACKAGE_STRING ""
-
-/* Define to the one symbol short name of this package. */
-#define PACKAGE_TARNAME ""
-
-/* Define to the version of this package. */
-#define PACKAGE_VERSION ""
-
-/* Define to 1 if you have the ANSI C header files. */
-#define STDC_HEADERS 1
-
-/* Version number of package */
-#define VERSION "3.0.11"
-
-/* Define to 1 if the X Window System is missing or not being used. */
-/* #undef X_DISPLAY_MISSING */
diff -uNr OLD/nurbs++-3.0.11/include/stamp-h nurbs++-3.0.11/include/stamp-h
--- OLD/nurbs++-3.0.11/include/stamp-h	2002-05-07 17:30:55.000000000 +0200
+++ nurbs++-3.0.11/include/stamp-h	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-timestamp
diff -uNr OLD/nurbs++-3.0.11/nurbs/d_surface.cpp nurbs++-3.0.11/nurbs/d_surface.cpp
--- OLD/nurbs++-3.0.11/nurbs/d_surface.cpp	2009-08-17 17:04:53.000000000 +0200
+++ nurbs++-3.0.11/nurbs/d_surface.cpp	2009-08-17 17:02:50.000000000 +0200
@@ -25,9 +25,7 @@
   template class InterPoint<double,2> ;
   template class InterPoint<double,3> ;
   
-  //TODO: External patcher's comment: BasicList not in PLib namespace?
-  //template class BasicList<InterPoint<double,2> > ; 
-  //template class BasicList<InterPoint<double,3> > ; 
+
   
   template class ParaSurface<double,2> ;
   template class ParaSurface<double,3> ;
@@ -38,3 +36,6 @@
 #endif 
 
 }
+
+template class BasicList<PLib::InterPoint<double,2> > ; 
+template class BasicList<PLib::InterPoint<double,3> > ; 
diff -uNr OLD/nurbs++-3.0.11/nurbs/f_surface.cpp nurbs++-3.0.11/nurbs/f_surface.cpp
--- OLD/nurbs++-3.0.11/nurbs/f_surface.cpp	2009-08-17 17:04:53.000000000 +0200
+++ nurbs++-3.0.11/nurbs/f_surface.cpp	2009-08-17 17:02:50.000000000 +0200
@@ -26,9 +26,7 @@
   template class InterPoint<float,3> ;
  
 
-//This breaks the "NO_IMPLICIT_TEMPLATES" thingy. Does BasicList not belong to PLib? 
-//  template class BasicList<InterPoint<float,2> > ; 
-//  template class BasicList<InterPoint<float,3> > ; 
+
   
   template class ParaSurface<float,2> ;
   template class ParaSurface<float,3> ;
@@ -40,3 +38,6 @@
 #endif 
 
 }
+
+template class BasicList<PLib::InterPoint<float,2> > ; 
+template class BasicList<PLib::InterPoint<float,3> > ; 
diff -uNr OLD/nurbs++-3.0.11/nurbs/nurbs.cpp nurbs++-3.0.11/nurbs/nurbs.cpp
--- OLD/nurbs++-3.0.11/nurbs/nurbs.cpp	2009-08-17 17:04:53.000000000 +0200
+++ nurbs++-3.0.11/nurbs/nurbs.cpp	2009-08-17 17:02:50.000000000 +0200
@@ -40,7 +40,7 @@
   \date 24 January 1997
 */
 template <class T, int N>
-NurbsCurve<T,N>::NurbsCurve(): P(1),U(1),deg_(0)
+NurbsCurve<T,N>::NurbsCurve(): P(1),U(1),deg_(0),Inverse_setted(0)
 {
 }
 
@@ -56,6 +56,7 @@
 NurbsCurve<T,N>::NurbsCurve(const NurbsCurve<T,N>& nurb): 
   ParaCurve<T,N>(), P(nurb.P),U(nurb.U),deg_(nurb.deg_)
 {
+  Inverse_setted = 0;
 }
 
 /*!
@@ -74,6 +75,7 @@
   int nSize = P1.n() ;
   int mSize = U1.n() ;
   deg_ = Degree ;
+  Inverse_setted = 0;
   if(nSize != mSize-deg_-1){
 #ifdef USE_EXCEPTION
     throw NurbsSizeError(P1.n(),U1.n(),Degree) ;
@@ -106,7 +108,7 @@
 template <class T, int N>
 NurbsCurve<T,N>::NurbsCurve(const Vector< HPoint_nD<T,N> >& P1, const Vector<T> &U1, int Degree): P(P1), U(U1), deg_(Degree) 
 {
-
+ Inverse_setted=0;
   if(P.n() != U.n()-deg_-1){
 #ifdef USE_EXCEPTION
     throw NurbsSizeError(P.n(),U.n(),deg_) ;
@@ -138,6 +140,7 @@
 {
   int nSize = P1.n() ;
   int mSize = U1.n() ;
+  Inverse_setted=0;
 
   if(nSize != mSize-deg_-1){
 #ifdef USE_EXCEPTION
@@ -385,7 +388,8 @@
   \author Philippe Lavoie 
   \date 25 July 1997
 */
-template<> template <class T, int N>
+template<>
+template <class T, int N>
 NurbsSurface<T,3> NurbsCurve<T,N>::drawAaImg(Image_Color& Img, const Color& color, const NurbsCurve<T,3>& profile, const NurbsCurve<T,3>& scaling, int precision, int alpha){
   Matrix<T> addMatrix ;
   Matrix_INT nMatrix ;
@@ -471,7 +475,8 @@
   \author Philippe Lavoie 
   \date 22 August 1997
 */
-template<> template <class T, int N>
+template<>
+template <class T, int N>
 void NurbsCurve<T,N>::transform(const MatrixRT<T>& A){
   for(int i=P.n()-1;i>=0;--i)
     P[i] = A*P[i] ;
@@ -502,7 +507,8 @@
   \author Philippe Lavoie 
   \date 24 January, 1997
 */
-template<> template <class T, int N>
+template<>
+template <class T, int N>
 HPoint_nD<T,N> NurbsCurve<T,N>::operator()(T u) const{
   static Vector<T> Nb ;
   int span = findSpan(u) ;
@@ -541,7 +547,8 @@
   \author Philippe Lavoie    
   \date 24 January, 1997
 */
-template<> template <class T, int N>
+template<>
+template <class T, int N>
 HPoint_nD<T,N> NurbsCurve<T,N>::hpointAt(T u, int span) const{
   static Vector<T> Nb ;
 
@@ -594,7 +601,8 @@
   \author  Philippe Lavoie
   \date 24 January, 1997
 */
-template<> template <class T, int N>
+template<>
+template <class T, int N>
 HPoint_nD<T,N> NurbsCurve<T,N>::derive(T u, int d) const {
   Vector< HPoint_nD<T,N> > ders ;
   deriveAtH(u,d,ders) ;
@@ -617,7 +625,8 @@
   \author  Philippe Lavoie
   \date 24 January, 1997
 */
-template<> template <class T, int N>
+template<>
+template <class T, int N>
 void NurbsCurve<T,N>::deriveAtH(T u,int d, Vector< HPoint_nD<T,N> >& ders) const{
   int du = minimum(d,deg_) ;
   int span ;
@@ -3101,6 +3110,91 @@
 }
 
 /*!
+  \brief  computes the Inverse for the compution of the control-points
+
+  \param v  kind of "span"-vector
+  \param V  a valid knot-vector
+  \param p  the degree of the curve
+  
+  \warning v and V have to be valid 
+  \author Philippe Lavoie 
+  \date 3 September, 1997
+*/
+template <class T, int D>
+Matrix<T> NurbsCurve<T,D>::computeInverse(const Vector<T> &v, const Vector<T> &V, const int p){  //changed 
+
+  int i,j;
+  int iN = V.n()-p-1;
+
+  resize(iN,p); //so findSpan works ... V has to be a valid knot-vector!!!!
+
+  U = V;
+
+  Matrix<T> A(iN,iN);
+
+ 
+  // Initialize the basis matrix A
+  Vector<T> N(p+1) ;
+
+  for(i=1;i<iN-1;i++){
+    int span = findSpan(v[i]);
+    basisFuns(v[i],span,N) ;
+    for(j=0;j<=p;j++) 
+	A(i,span-p+j) = (double)N[j] ;
+  }
+  A(0,0)  = 1.0 ;
+  A(iN-1,iN-1) = 1.0 ;
+
+  
+  LUMatrix<T> lu(A);
+  Inverse = lu.inverse();
+  Inverse_setted=1;
+  return Inverse;
+
+}
+
+/*!
+  \brief  computes the Inverse for the compution of the control-points on a closed curve
+
+  \param v  kind of "span"-vector
+  \param V  a valid knot-vector
+  \param p  the degree of the curve
+  
+  \warning v and V have to be valid 
+  \author Philippe Lavoie 
+  \date 3 September, 1997
+*/
+template <class T, int D>
+Matrix<T> NurbsCurve<T,D>::computeInverseClosed(const Vector<T> &v, const Vector<T> &V, const int p){  //changed
+
+  int i,j ;
+  int iN = V.n() - p - 1 - p - 1;
+
+  resize(V.n()-p-1,p); //so findSpan works ... V has to be a valid knot-vector!!!!
+
+  U = V;
+
+  Matrix<T> A(iN+1,iN+1) ;
+
+
+  // Initialize the basis matrix A
+  Vector<T> N(p+1) ;
+
+  for(i=0;i<=iN;i++){
+    int span = findSpan(v[i]);
+    basisFuns(v[i],span,N) ;
+    for(j=span-p;j<=span;j++) 
+      A(i,j%(iN+1)) = (double)N[j-span+p] ;
+  }
+
+  LUMatrix<T> lu(A);
+  Inverse = lu.inverse();
+  Inverse_setted=1;
+  return Inverse;
+}
+
+
+/*!
   \brief global curve interpolation with points in 4D
 
   Global curve interpolation with points in 4D
@@ -3256,7 +3350,8 @@
   int i,j ;
 
   resize(Q.n(),d) ;
-  Matrix_DOUBLE A(Q.n(),Q.n()) ;
+  //Matrix_DOUBLE A(Q.n(),Q.n()) ;
+
 
   if(Uc.n() != U.n()){
 #ifdef USE_EXCEPTION
@@ -3269,27 +3364,18 @@
 #endif
   }
   U = Uc ;
-  
-  // Initialize the basis matrix A
-  Vector<T> N(deg_+1) ;
 
-  for(i=1;i<Q.n()-1;i++){
-    int span = findSpan(ub[i]);
-    basisFuns(ub[i],span,N) ;
-    for(j=0;j<=deg_;j++) 
-	A(i,span-deg_+j) = (double)N[j] ;
-  }
-  A(0,0)  = 1.0 ;
-  A(Q.n()-1,Q.n()-1) = 1.0 ;
-
-  // Init matrix for LSE
-  Matrix_DOUBLE qq(Q.n(),D+1) ;
-  Matrix_DOUBLE xx(Q.n(),D+1) ;
+   // Init matrix for LSE
+  Matrix<T> qq(Q.n(),D+1) ;
+  Matrix<T> xx(Q.n(),D+1) ;
   for(i=0;i<Q.n();i++)
     for(j=0; j<D+1;j++)
       qq(i,j) = (double)Q[i].data[j] ;
 
-  solve(A,qq,xx) ;
+  if(Inverse_setted != 1) //changed
+    computeInverse(ub, Uc, d);
+   
+    xx = Inverse*qq;
 
   // Store the data
   for(i=0;i<xx.rows();i++){
@@ -3299,6 +3385,7 @@
 
 }
 
+
 template <class T, int N>
 inline T pow2(T a){
   return a*a ;
@@ -5300,7 +5387,7 @@
   }
   else{
     for(int i=0;i<ca.n();++i){
-      list2 = ca[i].tesselate(tolerance,uk) ;
+      list2 = ca[i].tesselate(tolerance,uk);
 
       // remove the last point from the list to elliminate
       list.erase((BasicNode<Point_nD<T,N> >*)list.last()) ;
@@ -6689,7 +6776,7 @@
   resize(Qw.n(),d) ;
 
   int iN = Qw.n() - d - 1;
-  Matrix_DOUBLE A(iN+1,iN+1) ;
+  //Matrix_DOUBLE A(iN+1,iN+1) ;
   
   if(Uc.n() != U.n()){
 #ifdef USE_EXCEPTION
@@ -6704,18 +6791,18 @@
   U = Uc ;
 
   // Initialize the basis matrix A
-  Vector<T> N(d+1) ;
+  //Vector<T> N(d+1) ;
 
-  for(i=0;i<=iN;i++){
-    int span = findSpan(ub[i]);
-    basisFuns(ub[i],span,N) ;
-    for(j=span-d;j<=span;j++) 
-      A(i,j%(iN+1)) = (double)N[j-span+d] ;
-  }
+  //for(i=0;i<=iN;i++){
+  //  int span = findSpan(ub[i]);
+  //  basisFuns(ub[i],span,N) ;
+  //  for(j=span-d;j<=span;j++) 
+  //    A(i,j%(iN+1)) = (double)N[j-span+d] ;
+  //}
 
   // Init matrix for LSE
-  Matrix_DOUBLE qq(iN+1,D+1) ;
-  Matrix_DOUBLE xx(iN+1,D+1) ;
+  Matrix<T> qq(iN+1,D+1) ;
+  Matrix<T> xx(iN+1,D+1) ;
   for(i=0;i<=iN ;i++)
     for(j=0; j<D+1;j++)
       qq(i,j) = (double)Qw[i].data[j] ;
@@ -6724,8 +6811,14 @@
   // using the SVD routine which works better when the system of
   // equations is very large (more than 50 points). Probably since in
   // this cases the system matrix A is very sparse.
-  SVDMatrix<double> svd(A) ;
-  svd.solve(qq,xx) ;
+
+  //SVDMatrix<double> svd(A) ;
+  //svd.solve(qq,xx) ;
+
+  if(Inverse_setted != 1)
+    Inverse = computeInverseClosed(ub,Uc,d);
+
+  xx = Inverse*qq;
 
   // Store the data
   for(i=0;i<xx.rows();i++){
diff -uNr OLD/nurbs++-3.0.11/nurbs/nurbs.h nurbs++-3.0.11/nurbs/nurbs.h
--- OLD/nurbs++-3.0.11/nurbs/nurbs.h	2002-05-13 23:07:46.000000000 +0200
+++ nurbs++-3.0.11/nurbs/nurbs.h	2009-08-17 17:02:50.000000000 +0200
@@ -58,6 +58,7 @@
     class NurbsCurve : public ParaCurve<T,N>{
     public:
       NurbsCurve() ;
+      NurbsCurve(Matrix<T> inverse){Inverse = inverse; Inverse_setted=1;} //changed
       NurbsCurve(const NurbsCurve<T,N>& nurb) ;
       NurbsCurve(const Vector< HPoint_nD<T,N> >& P1, const Vector<T> &U1, int deg=3) ;
       NurbsCurve(const Vector< Point_nD<T,N> >& P1, const Vector<T> &W, const Vector<T> &U1, int deg=3) ;
@@ -153,7 +154,6 @@
       void globalInterpH(const Vector< HPoint_nD<T,N> >& Q, int d);
       void globalInterpH(const Vector< HPoint_nD<T,N> >& Q, const Vector<T>& U, int d);
       void globalInterpH(const Vector< HPoint_nD<T,N> >& Q, const Vector<T>& ub, const Vector<T>& U, int d);
-      
       void globalInterpClosed(const Vector< Point_nD<T,N> >& Qw, int d);
       void globalInterpClosed(const Vector< Point_nD<T,N> >& Qw, const Vector<T>& ub, int d);
       void globalInterpClosedH(const Vector< HPoint_nD<T,N> >& Qw, int d);
@@ -162,7 +162,10 @@
       void globalInterpClosed(const Vector< Point_nD<T,N> >& Qw, const Vector<T>& ub, const Vector<T>& Uc, int d);
       
       void globalInterpD(const Vector< Point_nD<T,N> >& Q, const Vector< Point_nD<T,N> >& D, int d, int unitD, T a=1.0);
-      
+     
+      Matrix<T> computeInverse(const Vector<T> &v, const Vector<T> &V, const int p);
+      Matrix<T> computeInverseClosed(const Vector<T> &v, const Vector<T> &V, const int p);
+
       void projectTo(const Point_nD<T,N>& p, T guess, T& u, Point_nD<T,N>& r, T e1=0.001, T e2=0.001,int maxTry=100) const;
       
       
@@ -237,6 +240,9 @@
       Vector< HPoint_nD<T,N> > P; // the vector of control points
       Vector<T> U ;  // the knot vector
       int deg_ ;  // the degree of the NURBS curve
+
+      Matrix<T> Inverse; //changed
+      int Inverse_setted; //changed
     };
   
   typedef NurbsCurve<float,3> NurbsCurvef ;
diff -uNr OLD/nurbs++-3.0.11/nurbs/nurbsS.cpp nurbs++-3.0.11/nurbs/nurbsS.cpp
--- OLD/nurbs++-3.0.11/nurbs/nurbsS.cpp	2009-08-17 17:04:53.000000000 +0200
+++ nurbs++-3.0.11/nurbs/nurbsS.cpp	2009-08-17 17:02:50.000000000 +0200
@@ -741,8 +741,8 @@
     else {
       d = 0.0 ;
       for(k=1;k<n;k++){
-	d += cds[k] ;
-	uk[k] += d/total ;
+    	d += cds[k] ;
+        uk[k] += d/total ;
       }
     }
   }
@@ -926,6 +926,7 @@
   }
 }
 
+
 /*! 
   \brief Generates a surface using global interpolation with homogenous points
 
@@ -1595,6 +1596,8 @@
   // Resize to the proper number of control points  
   resizeKeep(S.P.rows(),mh-ph,S.degU,ph) ; 
 }
+
+
 /*!
   \brief Finds the multiplicity of a knot in the U knot
 
@@ -4554,6 +4557,56 @@
 
 }
 
+template <class T, int N>
+void NurbsSurface<T,N>::globalInterpClosedU_OwnKnotVecs(const Matrix< Point_nD<T,N> >& Q,const Vector<T> &Uk, const Vector<T> &Vk, const Vector<T> &uk, const Vector<T> &vk, int pU, int pV){
+  //Vector<T> vk,uk ;
+
+
+  if(degU != pU || degV != pV || U != Uk || V != Vk)
+   {
+      NurbsCurve<T,N> C1;
+      InverseV = C1.computeInverse(vk,Vk,pV);
+      NurbsCurve<T,N> C2;  
+      InverseU = C2.computeInverseClosed(uk,Uk,pU);
+   }  
+  resize(Q.rows(),Q.cols(),pU,pV) ;
+
+  //surfMeshParamsClosedU(Q,uk,vk,pU) ;
+  //knotAveragingClosed(uk,pU,U) ;
+  //knotAveraging(vk,pV,V) ;
+
+  U = Uk;
+  V = Vk;
+  //degU = pU;
+  //degV = pV;
+
+  Vector< HPoint_nD<T,N> > Pts(Q.cols()) ;
+  NurbsCurve<T,N> CV(InverseV);
+  
+  int i,j ;
+  for(i=0;i<Q.rows();i++){
+    for(j=0;j<Q.cols();j++)
+      Pts[j] = Q(i,j) ;
+    CV.globalInterpH(Pts,vk,V,degV) ;
+    for(j=0;j<Q.cols();j++)
+      P(i,j) = CV.ctrlPnts(j) ;
+  }
+
+  NurbsCurve<T,N> CU(InverseU);
+
+  Pts.resize(Q.rows()) ;
+  for(j=0;j<Q.cols();j++){
+    for(i=0;i<Q.rows();i++)
+      Pts[i] = P(i,j) ;
+    
+    CU.globalInterpClosedH(Pts,uk,U,degU);
+    for(i=0;i<Q.rows();i++)
+      P(i,j) = CU.ctrlPnts(i) ;
+  }
+
+}
+
+
 /*! 
   \brief Generates a surface using global interpolation. 
 
diff -uNr OLD/nurbs++-3.0.11/nurbs/nurbsS.h nurbs++-3.0.11/nurbs/nurbsS.h
--- OLD/nurbs++-3.0.11/nurbs/nurbsS.h	2002-05-13 23:07:46.000000000 +0200
+++ nurbs++-3.0.11/nurbs/nurbsS.h	2009-08-17 17:02:50.000000000 +0200
@@ -114,6 +114,7 @@
   void globalInterp(const Matrix< Point_nD<T,N> >& Q, int pU, int pV);
   void globalInterpH(const Matrix< HPoint_nD<T,N> >& Q, int pU, int pV);
   void globalInterpClosedU(const Matrix< Point_nD<T,N> >& Q, int pU, int pV);
+  void globalInterpClosedU_OwnKnotVecs(const Matrix< Point_nD<T,N> >& Q,const Vector<T> &Uk, const Vector<T> &Vk, const Vector<T> &uk, const Vector<T> &vk, int pU, int pV);//testing
   void globalInterpClosedUH(const Matrix< HPoint_nD<T,N> >& Q, int pU, int pV);
   void leastSquares(const Matrix< Point_nD<T,N> >& Q, int pU, int pV, int nU, int nV) ;
   void leastSquaresClosedU(const Matrix< Point_nD<T,N> >& Q, int pU, int pV, int nU, int nV) ;
@@ -146,7 +147,6 @@
   void degreeElevate(int tU, int tV) ;
   virtual void degreeElevateU(int tU) ;
   virtual void degreeElevateV(int tV) ;
-
   
   int decompose(NurbsSurfaceArray<T,N>& Sa) const ;
 
@@ -244,6 +244,10 @@
   Matrix< HPoint_nD<T,N> > P ; //!< The matrix of control points
   int degU ; //!< the degree of the surface in U
   int degV ; //!< the degree of the surface in V
+  
+  //changed 
+  Matrix<T> InverseU; //!< The matrix for the compution of the control points in U-direction
+  Matrix<T> InverseV; //!< The matrix for the compution of the control points in V-direction
 
 };
 
