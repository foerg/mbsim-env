\documentclass[10pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage{array}
\usepackage{listings}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\author{Fabien Péan, Thorsten Schindler}
\title{FMI 1.0 for MBSim}

\begin{document}
\maketitle

\begingroup
\let\cleardoublepage\relax
\let\clearpage\relax
\tableofcontents
\chapter*{Introduction}
This is the documentation of the implementation of the Functional Mock-up Interface 1.0 for Model Exchange (aka FMI) in the research code Multi-Body Simulation (aka MBSim) developed at the Applied Mechanics chair at the Technische Universität München (aka TUM). The goal in this documentation is to explain how it is implemented in MBSim but also, to explain how it is working in a computer point of view. This may be useful to understand the underlying problems encountered while exchanging Functional Mock-up Unit (aka FMU) files. Moreover, this could help you to understand how to implement it in another software without struggling to the basics, and start coding it faster. However, it is highly recommended to read the specification of the interface first, since the terms and the logic of the interface will not be described here.
\endgroup
%
\chapter{Understanding the process}
%
\section{The transfer of FMU}
%
\subsection*{The creation}
In our case, we will use MBSim as FMU generator. The first step is to write down the model to be exchanged, this will be explained in a later part. The next step is to generate the XML file compliant to FMI specification since this file will be added into the FMU archive.\par
%
From this point, only the packing of the FMU is left. It consists of putting in an archive the necessary data. In the end, the FMU archive contains the following hierarchy :
\begin{itemize}
\item[$\vdash$] binaries/
	\begin{itemize}
	\item[$\vdash$] linux/ or windows/
		\begin{itemize}
		\item[$\vdash$] library.so or .dll
		\item[$\vdash$] other dependent libraries
		\end{itemize}
	\end{itemize}
\item[$\vdash$] resources/
	\begin{itemize}
	\item[$\vdash$] maybe mbsimFlat.xml
	\end{itemize}
\item[$\vdash$] documentation/
\item[$\vdash$] sources/
\item[$\vdash$] modelDescription.xml
\end{itemize}
%
\subsection*{The usage}
The FMU previously created has been transferred to the recipient, who can now use it in another software. Basically one will load it into the master application. This master will read the modelDescription.xml file and load the library.so into its memory. Thanks to the information conveyed by the XML file, the application loader knows how to manipulate the data stored in the model described by the library.
%
\section{Details about underlying process}
%
\subsection*{About shared object libraries}
A shared object library is a file which contains binary code (i.e only 0 and 1), this binary code represents the different functions or classes you may have written. However, it does not contain any entry point, and by entry point it means a main function. Basically, you cannot run a library file like an application because it contains only "tools" : classes, functions, etc...\par
%
You use it without thinking about it while coding. Let us take a concrete example : When you write in a program cos(0.1), you have to include $<$math.h$>$ or $<$cmath$>$. This include is the header file containing the declaration of the functions. During first steps of the compilation process, the compiler knows that they exist but does not know where, yet. However at linking time, the compiler looks in its library path (directory path containing libraries *.so) and refers the symbol of cosinus to its actual place in the math.so file in memory. Finally, when you run the program, it sends the parameter 0.1 to cosinus contained at the place precised by math.so.\par
%
Yet another thing to know about libraries, they are keeping memory at the beginning of the file to list all their content and where they are located in the file. On Linux OS, you can see it explicitly by typing in terminal the command "nm -gC yourLib.so". In C, these symbols are simple and are the name of the functions or structures (figure~\ref{fig:libraryName}). However in C++, these names are said to be entangled and they are not the name of their declaration. This is due to the namespace and overloading principles (figure~\ref{fig:entanglement}).
%
\subsection*{The loading method}
Let us have a look at the application which is using the FMU. This one loads it, but how? As you may have seen, the FMU does NOT contain the header files of your implemented FMI interface. The reason behind it is that the FMU must be working at run-time, so you should not have to neither include the header file anywhere in the code source of the master application nor compile it. In consequences, the application is using a different method, which is called explicit loading of the library. The application is loading it directly into memory, but does not necessary know the content or how to use it. Fortunately, the FMI functions are to be in a C symbol style. The name of the functions, as in the original code source, are then the same as the one of the symbols, as in the shared library. This is performed by the keyword \textbf{extern} "C" wrapped around the fmiModelFunctions.h file in your implemented interface.\par
%
Since the application is supposed to load different FMU coming from different external creators, it cannot allow collision of functions with the same symbol name, because the program would not know to which definition to go. That is why, all the FMI functions are of the format specificCreatorName\_fmiFunctionX.\par
%
Let us have a concrete example : Simpack will be the master application and two FMUs, coming from MBSim and Modelica. \\-
First, Simpack wants to load the FMU from MBSim. It looks up in the modelDescription.xml for the model specifier and reads "mbsim". Then it loads the mbsim.so library and finds the addresses whose symbol names are mbsim\_fmiFunctionsX (mbsim\_fmiGetReal, etc...). From now on, Simpack knows how to access the model contained in the MBSim FMU. \\
Then, Simpack loads the FMU from Modelica, it looks up into the modelDescription.xml and reads "modelica" as model specifier. Simpack loads the library of the FMU in memory, and knows that to access the model contained in Modelica FMU, it has to retrieve the addresses of functions whose symbol names are modelica\_fmiFunctionX.
%
\begin{figure}
  \centering
  $
  \begin{array}{lll} 
  000000000000ea10 & T & \text{mbsim\_fmiCompletedIntegratorStep} \\ 
  0000000000010430 & T & \text{mbsim\_fmiEventUpdate} \\
  000000000000e590 & T & \text{mbsim\_fmiFreeModelInstance} \\
  \end{array}
  $
  \caption{Using "nm -g" on library from the MBSim FMU. 3 FMI functions displayed.}
  \label{fig:libraryName}
  
  $
  \begin{array}{lll} 
  000000000001f600 & T & \text{fmi::FmiXmlExport::buildDssFile()} \\
  000000000001f600 & T & \text{\_ZN3fmi12FmiXmlExport12buildDssFileEv} \\
  \end{array}
  $
  \caption{Example of name entanglement. First is decoded, second is not.}
  \label{fig:entanglement}
\end{figure}
%
\chapter{The implementation in MBSim}
%
\section{Dataflow}
%
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{fmi-uml}
	\caption{UML diagram of mbsimFmi}
	\label{fig:uml}
\end{figure}
%
The master is using the FMU by calling the FMI functions which are on the surface of the FMU. The FMI functions are calling methods of a ModelInstance which is the interface class to the overall hidden model. The ModelInstance class is the wrapper or adapter of the dynamic system described internally or by the flat XML file.\par
%
Regarding the solving of a dynamic system, please refer to the machine state representation in the FMI specification section 2.9. In mbsimfmi, this representation is actively used to describe the ModelInstance by a pair state/step which allows to control data access and update.
%
\section{Details about the code}
%
\subsection*{The ScalarVariable system}
The FMI version 1.0 uses a simple data description of a model. It requires to have variables being declared one by one in the file ModelDescription.xml, such that they are listed with a value reference which you can access in the FMU. Then in mbsimfmi, all variables of type (Real/Integer/String/Boolean) are gathered in a template class \emph{ScalarVariable<Type>}, together with their properties like variability and causality. This vector works as a kind of cache since it is not directly used by the FMU. The vector is decomposed by \emph{ScalarVariableContainer} which is used to aggregate (resp. dispatch) the information from (resp. to) individual units, wrapped in a template class \emph{ScalarVariableUnit}. \emph{ScalarVariableUnit} is the adapter class referring to the actual content of the FMU. It can be a value which has no impact in the dynamic model (output folder string) or which is a physical information (input, output of the system).
%
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{scalarvar}
	\caption{UML diagram of the ScalarVariable system}
	\label{fig:umlSV}
\end{figure}
%
\subsection*{Creation of model description XML file}
There are two main point of views to analyze the FMU: its creation and its usage. You need to describe in a \emph{ModelDescription.xml} the dynamic model in order to use it elsewhere. The creation is automatic with a given flat XML file (MBSim's own format of the dynamic system) or a system given by a system.cc-file. All necessary information for export is defined in the \emph{FmiXmlExport} class, accessible through the fmiexport-main application. The overall process is depicted in figure~\ref{fig:fmiexport}.
%
\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.6]{fmiexport}
	\caption{Step process of the XML creation}
	\label{fig:fmiexport}
\end{figure}
%
\section{Actual usage}
As a user of the FMI interface, you should start by defining the dynamic system you want to simulate. Two options are available: writing your system directly in the place of \emph{mbsimfmi/system.cc} or writing the flat XML file. A flat XML file can be conveniently created using mbsimgui, mbsimxml and renaming the .pp-file.\\
The creation of the ModelDescription.xml can be done either manually by calling the binary application fmixmlexport and providing the necessary argument, or by using the script \emph{pack\_FMU.sh} with the proper arguments. The script creates the ModelDescription.xml and packs all relevant information directly in a FMU archive. The usage is \\ 
bash \emph{pack\_FMU.sh /path/to/install/folder/ /mbsim/xml/flat/file.xml} \\
The first argument is mandatory, the second argument is optional. It depends on how you have created your dynamic system previously. When the archive is done, you can modify it or add some files, fix the ModelDescription.xml or add information to the ModelDescription.xml. Finally, you can use it with your other application. For example in Simpack, generate a general model template and add the control element 238 FMU Import defining the location of your FMU file.
%
\chapter{Information}
%
\section{Drawbacks \& important remarks}
Here are some important remarks on the code and its implementation :
%
\begin{itemize}
  \item First major information, \textbf{compile your FMU with the same (or older) version as the run-time library used by the master application}. For more details, the C libraries are sensitive to the compiler which generated them and the run-time library which is loading them. A conflict with the FMU shared libraries may occur due to the different version of the run-time library the master is using.
  %
  \item A script with trying the interface with some examples can be used to check that the interface works. The script can be found in example/runExamples.sh. It uses the fmuChecker application provided by FMI committee to run the FMUs with a simple integration scheme without root finding capability.
  %
  \item The automatic creation and usage of the FMU requires the developer who wants to add functionality (new input class, parameter, etc) to process the dynamic system the same way for the writing (in ModelDescription.xml) and the reading (in ModelInstance) in order to have a consistent value reference mapping. This is done in the code in the class FmiXmlExport (at the end of buildDssFile method in addXXX methods) and in ModelInstance (in setupX method)
  %
  \item The scalar variable system can be tricky to understand or to work with. The goal has been to have it isolated from the ModelInstance and to avoid an overweighted class.
\end{itemize}
%
\section{Future work}
\begin{itemize}
\item Do the implementation for Cosimulation, it differs by a few functions from Model Exchange.
%
\item The output of files H5 is bugging in Simpack. If plot recursive is enabled, Simpack crashes when simulation starts.
%
\item FMI specification for Model Exchange and Cosimulation version 2 has been released, recently. Thus, the interface needs to be updated accordingly.
\end{itemize}
%
\end{document}
